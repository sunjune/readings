Critical Rendering Path
关键渲染路径

Optimizing the critical rendering path is critical for improving performance of our pages: our goal is to prioritize and display the content that relates to the primary action the user wants to take on a page.
优化关键渲染对于提升我们的页面性能是很关键的：我们的目标是按最用户最关心的顺序显示页面内容。

Delivering a fast web experience requires a lot of work by the browser. Most of this work is hidden from us as web developers: we write the markup, and a nice looking page comes out on the screen. But how exactly does the browser go from consuming our HTML, CSS, and JavaScript to rendered pixels on the screen?
为了实现快速的页面体验需要由浏览器做大量的工作。这项工作的大部分对于我们web developer来说是看不到的：我们写下这些标记，而一个漂亮的页面就出现在屏幕上。但是浏览器到底是怎么把我们的HTML、CSS和JavaScript渲染成屏幕上的像素呢。

Optimizing for performance is all about understanding what happens in these intermediate steps between receiving the HTML, CSS, and JavaScript bytes and the required processing to turn them into rendered pixels - that’s the critical rendering path.
对性能的优化就是理解这个过程中中发生的一切，从接收到HTML、CSS和JavaScript到经过必需的运算来把它们转化成渲染过的像素 — 这就是关键渲染路径。

By optimizing the critical rendering path we can significantly improve the time to first render of our pages. Further, understanding the critical rendering path will also serve as a foundation for building well performing interactive applications. It turns out, the process for processing interactive updates is the same, just done in a continuous loop and ideally at 60 frames per second! However, let’s not get ahead of ourselves just yet. First, let’s take a quick, ground-up overview of how the browser goes about displaying a simple page.
通过优化关键渲染路径我们能大大提升首次渲染页面的用时。此外，对关键渲染路径的理解也将为建立良好性能的交互应用打好基础。其实，交互运算的更新过程也是这样的，只是理想情况下以每秒60帧的速度无限循环。当然了，现在还没到谈这个的时候。首先，让我们快速介绍一下浏览器是怎么显示一个简单页面的。

=======================================
Constructing the Object Model
构建对象模型
=======================================

Before the browser can render the page it needs to construct the DOM and CSSOM trees. As a result, we need to ensure that we deliver both the HTML and CSS to the browser as quickly as possible.
在浏览器能够渲染页面之前，它需要构建DOM和CSSOM树。也就是说，我们需要保证尽快把HTML和CSS提供给浏览器。

In this guide
本节内容

  ·Document Object Model (DOM)
  文档对象模型(DOM)
  ·CSS Object Model (CSSOM)
  CSS对象模型(CSSOM)

TL;DR
简而言之

  ·Bytes → characters → tokens → nodes → object model
  字节 → 字符 → 标记 → 节点 → 对象模型
  ·HTML markup is transformed into a Document Object Model (DOM), CSS markup is transformed into a CSS Object Model (CSSOM)
  HTML标记被转换成文档对象模型(DOM)，CSS标记被转换成CSS对象模型(CSSOM)
  ·DOM and CSSOM are independent data structures
  DOM和CSSOM都是独立的数据结构
  ·Chrome DevTools Timeline allows us to capture and inspect the construction and processing costs of DOM and CSSOM
  Chrome开发人员工具的时间轴让我们能捕捉并检查DOM和CSSOM的结构和运算开销

Document Object Model (DOM)
文档对象模型(DOM)

    <html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link href="style.css" rel="stylesheet">
        <title>Critical Path</title>
      </head>
      <body>
        <p>Hello <span>web performance</span> students!</p>
        <div><img src="awesome-photo.jpg"></div>
      </body>
    </html>

Let’s start, with the simplest possible case: a plain HTML page with some text and a single image. What does the browser need to do to process this simple page?
让我们开始吧，用一个最简单的例子：一个只有一些文字和一张图片的简单HTML页面。浏览器要做些什么来处理这个简单的页面呢。

  01 Conversion: the browser reads the raw bytes of the HTML off the disk or network and translates them to individual characters based on specified encoding of the file (e.g. UTF-8).
  转换：浏览器从磁盘或网络中读到原始的HTML内容，并按照指定的编码把它们翻译成独立的字符。

  02 Tokenizing: the browser converts strings of characters into distinct tokens specified by the W3C HTML5 standard - e.g. “<html>”, “<body>” and other strings within the “angle brackets”. Each token has a special meaning and a set of rules.
  标记化：浏览器把字符组成的字符串转换成明确的由W3C HTML5标准指定的标记 - 例如<html>、<body>以及其他的放在尖括号里的字符串。每个标记都有一个特殊的含意和一套规则。
  03 Lexing: the emitted tokens are converted into “objects” which define their properties and rules.
  词法分析：解析出来的标记被转换成定义他们属性和规则的对象
  04 DOM construction: Finally, because the HTML markup defines relationships between different tags (some tags are contained within tags) the created objects are linked in a tree data structure that also captures the parent-child relationships defined in the original markup: HTML object is a parent of the body object, the body is a parent of the paragraph object, and so on.
  DOM结构：最终，因为HTML标记定义了不同标签之间的关系(一些标签包含别的标签)创建出来的对象链结到一个由原始标记定义的父子关系的树结构上：HTML对象是body的父对象，body是段落的父对象，等等。

The final output of this entire process is the Document Object Model, or the “DOM” of our simple page, which the browser uses for all further processing of the page.
整个运算的最终输出结束就是文档对象模型，或者我们这个简单页面的DOM，浏览器用来做页面所有其他的运算。

Every time the browser has to process HTML markup it has to step through all of the steps above: convert bytes to characters, identify tokens, convert tokens to nodes, and build the DOM tree. This entire process can take some time, especially if we have a large amount of HTML to process.
每次浏览器要处理HTML标记的时候它都得按上面所有的步骤进行一遍：把字节转换成字符、识别标记、把标记转换成节点、构建DOM树。这整个过程要花一些时间，特别是我们有大量的HTML要处理的时候。

Note
注意

We'll assume that you have basic familiarity with Chrome DevTools - i.e. you know how to capture a network waterfall, or record a timeline. If you need a quick refresher, check out the Chrome Developer Tools documentation, or if you're new to DevTools, I recommend taking the Codeschool Discover DevTools course.
我们假定你对Chrome开发工具有一定的了解 - 例如，你知道怎么捕捉网络请求或者记录一条时间轴。如果你需要一个快速入门，请查阅Chrome开发人员工具文档(https://developers.google.com/chrome-developer-tools/)，或者如果你从来没用过开发工具，我推荐Codeschool Discover DevTools课程(http://discover-devtools.codeschool.com/)。

If you open up Chrome DevTools and record a timeline while the page is loaded, you can see the actual time taken to perform this step — in example above, it took us ~5ms to convert a chunk of HTML bytes into a DOM tree. Of course, if the page was larger, as most pages are, this process might take significantly longer. You will see in our future sections on creating smooth animations that this can easily become your bottleneck if the browser has to process large amounts of HTML. That said, let’s not get ahead of ourselves…
如果你在页面加载的时候打开Chrome开发工具并记录一个时间轴，你会看到执行某一步的确切时间点 — 在上面的示例中，要花5ms把一块HTML字节转换成DOM树。当然了，如果页面非常大，就象大部分页面那样，这个过程可能会花长得多的时间。你会在将来的课程里看到创建平滑动画，那很容易成为你的瓶颈，如果浏览器得去处理大量的HTML的话。

With the DOM tree ready, do we have enough information to render the page to the screen? Not yet! The DOM tree captures the properties and relationships of the document markup, but it does not tell us anything about how the element should look when rendered. That’s the responsibility of the CSSOM, which we turn to next!
当DOM树准备好以后，我们有足够的信息来把页面渲染到屏幕了吗？还没呢！DOM树拿到了文档标记的属性和关系，但是它没有告诉我们要把那些元素渲染成什么样。这是CSSOM要干的事，接下来我们就要讲到了。

CSS Object Model (CSSOM)
CSS对象模型(CSSOM)

While the browser was constructing the DOM of our simple page, it encountered a link tag in the head section of the document referencing an external CSS stylesheet: style.css. Anticipating that it will need this resource to render the page, it immediately dispatches a request for this resource, which comes back with the following content:
在浏览器构造我们那个简单页面的DOM的时候，它在文档头部遇到一个link标签引用了一个外部的CSS样式：style.css。它预感会需要这个资源来渲染页面，所以就立即发起一个请求加载这个资源，下面就是返回的内容：

    body { font-size: 16px }
    p { font-weight: bold }
    span { color: red }
    p span { display: none }
    img { float: right }

Of course, we could have declared our styles directly within the HTML markup (inline), but keeping our CSS independent of HTML allows us to treat content and design as separate concerns: the designers can work on CSS, developers can focus on HTML, and so on.
当然，我们可以直接把HTML标记里(行内)声明样式，但是保持CSS独立于HTML之外有助于我们将内容与设计分别处理：设计师来做CSS，开发人员专注于HTML等等。

Just as with HTML, we need to convert the received CSS rules into something that the browser can understand and work with. Hence, once again, we repeat a very similar process as we did with HTML:
只针对HTML来说，我们需要把接收到的CSS规则转换成浏览器可以理解并工作的东西。因此，又一次，我们象处理HTML那样重复了一个非常简单的过程：

  字节 → 字符 → 标记 → 节点 → CSSOM

The CSS bytes are converted into characters, then to tokens and nodes, and finally are linked into a tree structure known as the “CSS Object Model”, or CSSOM for short:
CSS字节被转换成字符，然后是标记和节点，最终被链接到被称为“CSS 对象模型”的树结构上，或者简称为CSSOM：

Why does the CSSOM have a tree structure? When computing the final set of styles for any object on the page, the browser starts with the most general rule applicable to that node (e.g. if it is a child of body element, then all body styles apply) and then recursively refines the computed styles by applying more specific rules - i.e. the rules “cascade down”.
To make it more concrete, consider the CSSOM tree above. Any text contained within the span tag that is placed within the body element will have a font size of 16 pixels and have red text - the font-size directive cascades down from body to the span. However, if a span tag is child of a paragraph (p) tag, then its contents are not displayed.
为什么CSSOM会有树结构呢？在为页面上所有对象计算最终的样式时，浏览器启动该节点最常用的规则(例如，如果它是body的子元素，那么所有body的样式都会应用于它)然后通过应用更多特定规则来递归完善计算过的样式 — 例如，"cascade down"规则。再具体一点讲，考虑到上面的CSSOM树。包含在body元素中span标签里的任何文本都会是16像素的字体大小颜色是红色 — 字体大小的设置从body继承给span。然而，如果span标签是段落(p)的子元素，那么它的内容就不显示。

Also, note that the above tree is not the complete CSSOM tree and only shows the styles we decided to override in our stylesheet. Every browser provides a default set of styles also known as “user agent styles” – that’s what we see when we don’t provide any of our own – and our styles simply override these defaults (e.g. default IE styles). If you have ever inspected your “computed styles” in Chrome DevTools and wondered where all the styles are coming from, now you know!
要注意到上面的树不是完整的CSSOM树，而且只列出了我们决定重置样式表的那些样式。每个浏览器都提供了一套默认样式也被称为“用户代理样式” — 在没有任何自定义样式的时候我们所看到的 — 而我们的样式只是简单地覆盖了这些默认值(例如默认的IE样式)。如果你曾在Chrome的开发工具中检查过“计算过的样式”并且奇怪这些样式都是从哪来的，现在你就知道了。

Curious to know how long the CSS processing took? Record a timeline in DevTools and look for “Recalculate Style” event: unlike DOM parsing, the timeline doesn’t show a separate “Parse CSS” entry, and instead captures parsing and CSSOM tree construction, plus the recursive calculation of computed styles under this one event.
想知道CSS计算需要多长时间吗？在开发工具中记录一个时间线并查找“重算样式”事件：与DOM的解析不同，时间线上不会显示一个独立的“解析CSS”分支，而且不捕获解析和CSSOM构造，加上这个事件中的计算过的样式的递归运算。

Our trivial stylesheet takes ~0.6ms to process and affects 8 elements on the page – not much, but once again, not free. However, where did the 8 elements come from? The CSSOM and DOM and are independent data structures! Turns out, the browser is hiding an important step. Next, lets talk about the render tree that links the DOM and CSSOM together.
我们那点无关紧要的样式表用了大约0.6ms来计算并影响了8个元素 – 不是很多，但是再说一次，这是要花时间的。然而，这8个元素是哪来的？CSSOM和DOM和独立数据结构！这说明，浏览器隐藏了一个重要步骤。接下来，让我们谈谈把DOM和CSSOM联结起来的渲染树。


===============================================
Render-tree construction, Layout, and Paint
渲染树结构、布局和绘制
===============================================

The CSSOM and DOM trees are combined into a render tree, which is then used to compute the layout of each visible element and serves as an input to the paint process which renders the pixels to screen. Optimizing each of these steps is critical to achieve optimal rendering performance.
In the previous section on constructing the object model, we built the DOM and the CSSOM trees based on the HTML and CSS input. However, both of these are independent objects which capture different aspects of the document: one describes the content and the other the style rules that need to be applied to the document. How do we merge the two and get the browser to render pixels on the screen?













Udacity course
Udacity课程

Interested in taking a deep dive into the Critical Rendering Path? Check out or companion course and learn how the browser converts HTML, CSS, and JavaScript to pixels on the screen, how to use DevTools to measure performance, and how to optimize the Critical Rendering Path of your pages.
对关键渲染路径有兴趣再深入一些？请查阅合作课程理解浏览器是如何把HTML、CSS和JavaScript转换成屏幕上的像素，如何使用开发工具来测量性能，以及如果优化你页面的关键渲染路径。









