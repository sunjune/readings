Critical Rendering Path
关键渲染路径

Optimizing the critical rendering path is critical for improving performance of our pages: our goal is to prioritize and display the content that relates to the primary action the user wants to take on a page.
优化关键渲染对于提升我们的页面性能是很关键的：我们的目标是按最用户最关心的顺序显示页面内容。

Delivering a fast web experience requires a lot of work by the browser. Most of this work is hidden from us as web developers: we write the markup, and a nice looking page comes out on the screen. But how exactly does the browser go from consuming our HTML, CSS, and JavaScript to rendered pixels on the screen?
为了实现快速的页面体验需要由浏览器做大量的工作。这项工作的大部分对于我们web developer来说是看不到的：我们写下这些标记，而一个漂亮的页面就出现在屏幕上。但是浏览器到底是怎么把我们的HTML、CSS和JavaScript渲染成屏幕上的像素呢。

Optimizing for performance is all about understanding what happens in these intermediate steps between receiving the HTML, CSS, and JavaScript bytes and the required processing to turn them into rendered pixels - that’s the critical rendering path.
对性能的优化就是理解这个过程中中发生的一切，从接收到HTML、CSS和JavaScript到经过必需的运算来把它们转化成渲染过的像素 — 这就是关键渲染路径。

By optimizing the critical rendering path we can significantly improve the time to first render of our pages. Further, understanding the critical rendering path will also serve as a foundation for building well performing interactive applications. It turns out, the process for processing interactive updates is the same, just done in a continuous loop and ideally at 60 frames per second! However, let’s not get ahead of ourselves just yet. First, let’s take a quick, ground-up overview of how the browser goes about displaying a simple page.
通过优化关键渲染路径我们能大大提升首次渲染页面的用时。此外，对关键渲染路径的理解也将为建立良好性能的交互应用打好基础。其实，交互运算的更新过程也是这样的，只是理想情况下以每秒60帧的速度无限循环。当然了，现在还没到谈这个的时候。首先，让我们快速介绍一下浏览器是怎么显示一个简单页面的。

=======================================
Constructing the Object Model
构建对象模型
=======================================

Before the browser can render the page it needs to construct the DOM and CSSOM trees. As a result, we need to ensure that we deliver both the HTML and CSS to the browser as quickly as possible.
在浏览器能够渲染页面之前，它需要构建DOM和CSSOM树。也就是说，我们需要保证尽快把HTML和CSS提供给浏览器。

In this guide
本节内容

  ·Document Object Model (DOM)
  文档对象模型(DOM)
  ·CSS Object Model (CSSOM)
  CSS对象模型(CSSOM)

TL;DR
简而言之

  ·Bytes → characters → tokens → nodes → object model
  字节 → 字符 → 标记 → 节点 → 对象模型
  ·HTML markup is transformed into a Document Object Model (DOM), CSS markup is transformed into a CSS Object Model (CSSOM)
  HTML标记被转换成文档对象模型(DOM)，CSS标记被转换成CSS对象模型(CSSOM)
  ·DOM and CSSOM are independent data structures
  DOM和CSSOM都是独立的数据结构
  ·Chrome DevTools Timeline allows us to capture and inspect the construction and processing costs of DOM and CSSOM
  Chrome开发人员工具的时间轴让我们能捕捉并检查DOM和CSSOM的结构和运算开销

Document Object Model (DOM)
文档对象模型(DOM)

    <html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link href="style.css" rel="stylesheet">
        <title>Critical Path</title>
      </head>
      <body>
        <p>Hello <span>web performance</span> students!</p>
        <div><img src="awesome-photo.jpg"></div>
      </body>
    </html>

Let’s start, with the simplest possible case: a plain HTML page with some text and a single image. What does the browser need to do to process this simple page?
让我们开始吧，用一个最简单的例子：一个只有一些文字和一张图片的简单HTML页面。浏览器要做些什么来处理这个简单的页面呢。

  01 Conversion: the browser reads the raw bytes of the HTML off the disk or network and translates them to individual characters based on specified encoding of the file (e.g. UTF-8).
  转换：浏览器从磁盘或网络中读到原始的HTML内容，并按照指定的编码把它们翻译成独立的字符。

  02 Tokenizing: the browser converts strings of characters into distinct tokens specified by the W3C HTML5 standard - e.g. “<html>”, “<body>” and other strings within the “angle brackets”. Each token has a special meaning and a set of rules.
  标记化：浏览器把字符组成的字符串转换成明确的由W3C HTML5标准指定的标记 - 例如<html>、<body>以及其他的放在尖括号里的字符串。每个标记都有一个特殊的含意和一套规则。
  03 Lexing: the emitted tokens are converted into “objects” which define their properties and rules.
  词法分析：解析出来的标记被转换成定义他们属性和规则的对象
  04 DOM construction: Finally, because the HTML markup defines relationships between different tags (some tags are contained within tags) the created objects are linked in a tree data structure that also captures the parent-child relationships defined in the original markup: HTML object is a parent of the body object, the body is a parent of the paragraph object, and so on.
  DOM结构：最终，因为HTML标记定义了不同标签之间的关系(一些标签包含别的标签)创建出来的对象链结到一个由原始标记定义的父子关系的树结构上：HTML对象是body的父对象，body是段落的父对象，等等。

The final output of this entire process is the Document Object Model, or the “DOM” of our simple page, which the browser uses for all further processing of the page.
整个运算的最终输出结束就是文档对象模型，或者我们这个简单页面的DOM，浏览器用来做页面所有其他的运算。

Every time the browser has to process HTML markup it has to step through all of the steps above: convert bytes to characters, identify tokens, convert tokens to nodes, and build the DOM tree. This entire process can take some time, especially if we have a large amount of HTML to process.
每次浏览器要处理HTML标记的时候它都得按上面所有的步骤进行一遍：把字节转换成字符、识别标记、把标记转换成节点、构建DOM树。这整个过程要花一些时间，特别是我们有大量的HTML要处理的时候。

Note
注意

We'll assume that you have basic familiarity with Chrome DevTools - i.e. you know how to capture a network waterfall, or record a timeline. If you need a quick refresher, check out the Chrome Developer Tools documentation, or if you're new to DevTools, I recommend taking the Codeschool Discover DevTools course.
我们假定你对Chrome开发工具有一定的了解 - 例如，你知道怎么捕捉网络请求或者记录一条时间轴。如果你需要一个快速入门，请查阅Chrome开发人员工具文档(https://developers.google.com/chrome-developer-tools/)，或者如果你从来没用过开发工具，我推荐Codeschool Discover DevTools课程(http://discover-devtools.codeschool.com/)。

If you open up Chrome DevTools and record a timeline while the page is loaded, you can see the actual time taken to perform this step — in example above, it took us ~5ms to convert a chunk of HTML bytes into a DOM tree. Of course, if the page was larger, as most pages are, this process might take significantly longer. You will see in our future sections on creating smooth animations that this can easily become your bottleneck if the browser has to process large amounts of HTML. That said, let’s not get ahead of ourselves…
如果你在页面加载的时候打开Chrome开发工具并记录一个时间轴，你会看到执行某一步的确切时间点 — 在上面的示例中，要花5ms把一块HTML字节转换成DOM树。当然了，如果页面非常大，就象大部分页面那样，这个过程可能会花长得多的时间。你会在将来的课程里看到创建平滑动画，那很容易成为你的瓶颈，如果浏览器得去处理大量的HTML的话。

With the DOM tree ready, do we have enough information to render the page to the screen? Not yet! The DOM tree captures the properties and relationships of the document markup, but it does not tell us anything about how the element should look when rendered. That’s the responsibility of the CSSOM, which we turn to next!
当DOM树准备好以后，我们有足够的信息来把页面渲染到屏幕了吗？还没呢！DOM树拿到了文档标记的属性和关系，但是它没有告诉我们要把那些元素渲染成什么样。这是CSSOM要干的事，接下来我们就要讲到了。

CSS Object Model (CSSOM)
CSS对象模型(CSSOM)

While the browser was constructing the DOM of our simple page, it encountered a link tag in the head section of the document referencing an external CSS stylesheet: style.css. Anticipating that it will need this resource to render the page, it immediately dispatches a request for this resource, which comes back with the following content:
在浏览器构造我们那个简单页面的DOM的时候，它在文档头部遇到一个link标签引用了一个外部的CSS样式：style.css。它预感会需要这个资源来渲染页面，所以就立即发起一个请求加载这个资源，下面就是返回的内容：

    body { font-size: 16px }
    p { font-weight: bold }
    span { color: red }
    p span { display: none }
    img { float: right }

Of course, we could have declared our styles directly within the HTML markup (inline), but keeping our CSS independent of HTML allows us to treat content and design as separate concerns: the designers can work on CSS, developers can focus on HTML, and so on.
当然，我们可以直接把HTML标记里(行内)声明样式，但是保持CSS独立于HTML之外有助于我们将内容与设计分别处理：设计师来做CSS，开发人员专注于HTML等等。

Just as with HTML, we need to convert the received CSS rules into something that the browser can understand and work with. Hence, once again, we repeat a very similar process as we did with HTML:
只针对HTML来说，我们需要把接收到的CSS规则转换成浏览器可以理解并工作的东西。因此，又一次，我们象处理HTML那样重复了一个非常简单的过程：

  字节 → 字符 → 标记 → 节点 → CSSOM

The CSS bytes are converted into characters, then to tokens and nodes, and finally are linked into a tree structure known as the “CSS Object Model”, or CSSOM for short:
CSS字节被转换成字符，然后是标记和节点，最终被链接到被称为“CSS 对象模型”的树结构上，或者简称为CSSOM：

Why does the CSSOM have a tree structure? When computing the final set of styles for any object on the page, the browser starts with the most general rule applicable to that node (e.g. if it is a child of body element, then all body styles apply) and then recursively refines the computed styles by applying more specific rules - i.e. the rules “cascade down”.
To make it more concrete, consider the CSSOM tree above. Any text contained within the span tag that is placed within the body element will have a font size of 16 pixels and have red text - the font-size directive cascades down from body to the span. However, if a span tag is child of a paragraph (p) tag, then its contents are not displayed.
为什么CSSOM会有树结构呢？在为页面上所有对象计算最终的样式时，浏览器启动该节点最常用的规则(例如，如果它是body的子元素，那么所有body的样式都会应用于它)然后通过应用更多特定规则来递归完善计算过的样式 — 例如，"cascade down"规则。再具体一点讲，考虑到上面的CSSOM树。包含在body元素中span标签里的任何文本都会是16像素的字体大小颜色是红色 — 字体大小的设置从body继承给span。然而，如果span标签是段落(p)的子元素，那么它的内容就不显示。

Also, note that the above tree is not the complete CSSOM tree and only shows the styles we decided to override in our stylesheet. Every browser provides a default set of styles also known as “user agent styles” – that’s what we see when we don’t provide any of our own – and our styles simply override these defaults (e.g. default IE styles). If you have ever inspected your “computed styles” in Chrome DevTools and wondered where all the styles are coming from, now you know!
要注意到上面的树不是完整的CSSOM树，而且只列出了我们决定重置样式表的那些样式。每个浏览器都提供了一套默认样式也被称为“用户代理样式” — 在没有任何自定义样式的时候我们所看到的 — 而我们的样式只是简单地覆盖了这些默认值(例如默认的IE样式)。如果你曾在Chrome的开发工具中检查过“计算过的样式”并且奇怪这些样式都是从哪来的，现在你就知道了。

Curious to know how long the CSS processing took? Record a timeline in DevTools and look for “Recalculate Style” event: unlike DOM parsing, the timeline doesn’t show a separate “Parse CSS” entry, and instead captures parsing and CSSOM tree construction, plus the recursive calculation of computed styles under this one event.
想知道CSS计算需要多长时间吗？在开发工具中记录一个时间线并查找“重算样式”事件：与DOM的解析不同，时间线上不会显示一个独立的“解析CSS”分支，而且不捕获解析和CSSOM构造，加上这个事件中的计算过的样式的递归运算。

Our trivial stylesheet takes ~0.6ms to process and affects 8 elements on the page – not much, but once again, not free. However, where did the 8 elements come from? The CSSOM and DOM and are independent data structures! Turns out, the browser is hiding an important step. Next, lets talk about the render tree that links the DOM and CSSOM together.
我们那点无关紧要的样式表用了大约0.6ms来计算并影响了8个元素 – 不是很多，但是再说一次，这是要花时间的。然而，这8个元素是哪来的？CSSOM和DOM和独立数据结构！这说明，浏览器隐藏了一个重要步骤。接下来，让我们谈谈把DOM和CSSOM联结起来的渲染树。


===============================================
Render-tree construction, Layout, and Paint
渲染树结构、布局和绘制
===============================================

The CSSOM and DOM trees are combined into a render tree, which is then used to compute the layout of each visible element and serves as an input to the paint process which renders the pixels to screen. Optimizing each of these steps is critical to achieve optimal rendering performance.
CSSOM和DOM树被绑定成渲染树，然后被用来计算每个可视元素的布局并为绘制进程提供输入项，由它来向屏幕上渲染像素点。优化这里的每一步对于达成最佳渲染性能是很关键的。

In the previous section on constructing the object model, we built the DOM and the CSSOM trees based on the HTML and CSS input. However, both of these are independent objects which capture different aspects of the document: one describes the content and the other the style rules that need to be applied to the document. How do we merge the two and get the browser to render pixels on the screen?
在前面构建对象模型的章节，我们基于HTML和CSS构建了DOM和CSSOM树输入项。然而，所有这些都是反映document不同角度的独立对象：一个是对内容的描述另一个是需要应用于document的样式规则。我们要如何合并这两者并让浏览器在屏幕上渲染像素点呢？

TL;DR
简而言之

  ·The DOM and CSSOM trees are combined to form the render tree
  DOM和CSSOM被结合来构成渲染树
  ·Render tree contains only the nodes required to render the page
  渲染树只包含需要用于渲染页面的节点
  ·Layout computes the exact position and size of each object
  布局计算每个对象最急需的位置和大小
  ·Paint is the last step that takes in the final render tree and renders the pixels to the screen
  绘制是最后一步，得到最终的渲染树并在屏幕上渲染像素点

The first step is for the browser to combine the DOM and CSSOM into a “render tree” that captures all the visible DOM content on the page, plus all the CSSOM style information for each node.
浏览器把DOM和CSSOM结合成渲染树的第一步，就是拿到页面上所有可视的DOM内容，给每个节点加总CSSOM样式信息。

To construct the render tree, the browser roughly does the following:
为了构建渲染树，浏览器大致要做以下事项：

  01 Starting at the root of the DOM tree, traverse each visible node.
  从DOM树的根开始，遍历所有可视节点
    ·Some nodes are not visible at all (e.g. script tags, meta tags, and so on), and are omitted since they are not reflected in the rendered output.
    有些节点根据不可见(例如，script标签、meta标签等等)，且因为它们不在渲染输入项中而被略去
    ·Some nodes are hidden via CSS and are also omitted from the render tree - e.g. the span node in example above is missing from the render tree because we have an explicit rule that sets “display: none” property on it.
    有些节点被CSS隐藏并且也从渲染树中略去 — 例如，上面示例中的span节点也在渲染树中被忽略因为我们给它加了“display: none”属性。
  02 For each visible node find the appropriate matching CSSOM rules and apply them.
  对于每个可视节点，找到合适匹配CSSOM规则并应用给它们
  03 Emit visible nodes with content and their computed styles.
  放出可带内容的可视节点以及它们计算过的样式


Remember
切记

  ·As a brief aside, note that 'visibility: hidden' is different from 'display: none'. The former makes the element invisible, but the element is still occupies space in the layout (i.e. it's rendered as an empty box), whereas the latter (display: none) removes the element entirely from the render tree such that the element is invisible and is not part of layout.
  简单插一句，请注意'visibility: hidden'和'display: none'是不同的。前者使得元素不可见，但是元素依然占用着布局的空间(换句话说，它是当成一个空的容器来渲染的)，但是后者(display: none)从渲染树中整个移除了元素所以元素不可见且不是布局中的一部分。


The final output is a render that contains both the content and the style information of all the visible content on the screen - we’re getting close! With the render tree in place, we can proceed to the “layout” stage.
最终输出的是包含了屏幕上所有可见内容和样式信息的渲染 — 我们就要完成了。有了在适当位置的渲染树，我们就能前进到“布局”的阶段了。

Up to this point we’ve calculated which nodes should be visible and their computed styles, but we have not calculated their exact position and size within the viewport of the device - that’s the “layout” stage, also sometimes known as “reflow.”
直到这时我们已经计算了那些可见的节点以及它们计算过的样式，但是我们还没计算在设备的可视屏显中它们确切的位置和大小 — 这就是“布局”阶段，有时候也被称为“流回”。

To figure out the exact size and position of each object the browser begins at the root of the render tree and traverses it to compute the geometry of each object on the page. Let’s consider a simple hands-on example:
要算出每个对象确切的大小和位置，浏览器从渲染树的根开始来遍历并计算页面中每个对象的几何形状。我们来动手写一个简单示例：

    <html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <title>Critial Path: Hello world!</title>
      </head>
      <body>
        <div style="width: 50%">
          <div style="width: 50%">Hello world!</div>
        </div>
      </body>
    </html>

The body of the above page contains two nested div’s: the first (parent) div sets the display size of the node to 50% of the viewport width, and the second div contained by the parent sets its width to be 50% of its parent - i.e. 25% of the viewport width!
上述页面的body中包含了两个嵌套的div：第一个(父)div设置了节点显示大小为可视屏显宽度的50%，被父节点包含的第二个div设置宽度为父节点宽度的50% — 也就是可视屏显宽度的25%。

The output of the layout process is a “box model” which precisely captures the exact position and size of each element within the viewport: all of the relative measures are converted to absolute pixels positions on the screen, and so on.
布局运算的输出结果是“盒模型”，它得到了可视屏显中每个元素的确切位置和大小：所有的相对尺寸都被转换成了屏幕上绝对坐标像素点，等等。

Finally, now that we know which nodes are visible, their computed styles, and geometry, we can finally pass this information to our final stage which will convert each node in the render tree to actual pixels on the screen - this step is often referred to as “painting” or “rasterizing.”
最后，现在我们知道有哪些可见的节点、它们计算过的样式、几何形状，我们最终能够将该信息传给最后的阶段，把渲染树里的每个节点转换成实际屏幕上的像素点 — 这个步骤经常显示成“绘制”或者“光栅化”。

Did you follow all of that? Each of these steps requires a non-trivial amount of work by the browser, which also means that it can often take quite a bit of time. Thankfully, Chrome DevTools can help us get some insight into all three of the stages we’ve described above. Let’s examine the layout stage for our original “hello world” example:
你曾跟踪过所有这些步骤吗？这里的每一步都要由浏览器完成一定量的工作，也就意味着通常要花一点时间。幸好，Chrome的开发工具能够帮助我们对上述三个阶段获得一些直观视图。让我们来检查一下我们那个“hello world”示例的布局阶段：

  ·The render tree construction and position and size calculation are captured with the “Layout” event in the Timeline.
  时间线中，渲染树结构和以及位置和大小的运算被集合在“布局”事件中。
  ·Once layout is complete, the browser issues a “Paint Setup” and “Paint” events which convert the render tree to actual pixels on the screen.
  一旦布局结束，浏览器就会放出“绘制开始”和“绘制”事件，那就是把渲染树转换成屏幕上实际的像素点。

The time required to perform render tree construction, layout and paint will vary based on the size of the document, the applied styles, and of course, the device it is running on: the larger the document the more work the browser will have to do; the more complicated the styles are the more time will be consumed for painting also (e.g. a solid color is “cheap” to paint, and a drop shadow is much more “expensive” to compute and render).
用来处理渲染树结构、布局和绘制所需的时间，会因文档大小、应用的样式、当然还有运行在什么设备上而有所不同：文档越大浏览器要干的就越多、样式越复杂也就要花越多的时间来绘制(例如：纯色绘制起来很“便宜”，而阴影在运算和渲染的时候就“贵”得多了)。

Once all is said and done, our page is finally visible in the viewport - woohoo!
所说的这些都完成的时候，我们的页面就最终呈现在可视屏显中了。

Let’s do a quick recap of all the steps the browser went through:
让我们对浏览器做过的所有步骤做一个总结：

  01 Process HTML markup and build the DOM tree
  处理HTML标记并且建立DOM树
  02 Process CSS markup and build the CSSOM tree
  处理CSS标记并且建立CSSOM树
  03 Combine the DOM and CSSOM into a render tree
  将DOM和CSSOM结合成渲染树
  04 Run layout on the render tree to compute geometry of each node
  在渲染树的基础上生成布局,计算每个节点的形状
  05 Paint the individual nodes to the screen
  将单独的节点绘制到屏幕上

Our demo page may look very simple, but it requires quite a bit of work! Care to guess what would happen if the DOM, or CSSOM is modified? We would have to repeat the same process over again to figure out which pixels need to be re-rendered on the screen.
我们的示例页看起来非常简单，但是它也要做不少事。小心猜一下如果DOM或CSSOM被修改了会发生什么？我们得把同样的过程再做一遍来找到要在屏幕上重新渲染哪些像素点。

Optimizing the critical rendering path is the process of minimizing the total amount of time spent in steps 1 through 5 in the above sequence. Doing so enables us to render content to the screen as soon as possible and also to reduces the amount of time between screen updates after the initial render - i.e. achieve higher refresh rate for interactive content.
优化关键渲染路径就是将按上述顺序把步骤1到步骤5所要花费的时间最小化。这样做能让我们尽可能快的把内容渲染到屏幕上，而且减少在初始渲染后屏幕更新要花的时间 — 也就是说为交互内容实现更高的刷新率。


=======================================
Render Blocking CSS
阻止渲染的CSS
=======================================

By default CSS is treated as a render blocking resource, which means that the browser will hold rendering of any processed content until the CSSOM is constructed. Make sure to keep your CSS lean, deliver it as quickly as possible, and use media types and queries to unblock rendering.
默认状态下CSS被当成阻止渲染资源，这意味着浏览器将停止渲染任何处理过的内容直到CSSOM被建成。确保你的CSS简洁，尽可能快地分发出去，并且使用媒体类型和侦测来解锁渲染。

In the previous section we saw that the critical rendering path requires that we have both the DOM and the CSSOM to construct the render tree, which creates an important performance implication: both HTML and CSS are render blocking resources. The HTML is obvious, since without the DOM we would not have anything to render, but the CSS requirement may be less obvious. What would happen if we try to render a typical page without blocking rendering on CSS?
在前面的章节我们看到了关键渲染路径需要我们将DOM和CSSOM构建成渲染树，而这对性能产生重大影响：HTML和CSS都是渲染阻止资源。HTML很明显，因为没有DOM我们都不知道要渲染什么，但是CSS的需求就没那么明显。如果我们试图去渲染一个典型的没有CSS阻止渲染的页面会发生什么呢？

TL;DR
简而言之

  ·By default CSS is treated as a render blocking resource
  默认情况下CSS被当成阻止渲染资源
  ·Media types and media queries allow us to mark some CSS resources as non render blocking
  媒体类型和媒体侦测允许我们将一部分CSS资源标记成不阻止渲染
  ·All CSS resources, regardless of blocking or non-blocking behavior are downloaded by the browser
  所有CSS资源、不管是阻止或不阻止行为都会被浏览器下载

The above example, showing the NYTimes website with and without CSS, demonstrates why rendering is blocked until CSS is available - without CSS the page is effectively unusable. In fact, the experience on the right is often referred to as a “Flash of Unstyled Content” (FOUC). As a result, the browser will block rendering until it has both the DOM and the CSSOM.
上面示例，展示了NYTimes网站带或不带CSS的样子，表明了为何直到CSS可用之前渲染都是被阻止的 — 没有CSS页面事实上是没用的。

CSS is a render blocking resource, get it down to the client as soon and as quickly as possible to optimize the time to first render!
CSS是会阻止渲染的资源，要尽可能快地把它下载到客户端以优化首次渲染的时间。

However, what if we have some CSS styles that are only used under certain conditions, for example, when the page is being printed, or being projected onto a large monitor? It would be nice if we didn’t have to block rendering on these resources!
然而，假如我们有一些只用于某些条件的CSS样式呢，例如，当页面正在被绘制或正在规划放在大屏幕上？如果我们不用阻止渲染这些资源那会很好啊。

CSS “media types” and “media queries” allow us to address these use-cases:
CSS中的“媒体类型”和“媒体侦测”允许我们定位这些用例：

<link href="style.css" rel="stylesheet">
<link href="print.css" rel="stylesheet" media="print">
<link href="other.css" rel="stylesheet" media="(min-width: 40em)">























Udacity course
Udacity课程

Interested in taking a deep dive into the Critical Rendering Path? Check out or companion course and learn how the browser converts HTML, CSS, and JavaScript to pixels on the screen, how to use DevTools to measure performance, and how to optimize the Critical Rendering Path of your pages.
对关键渲染路径有兴趣再深入一些？请查阅合作课程理解浏览器是如何把HTML、CSS和JavaScript转换成屏幕上的像素，如何使用开发工具来测量性能，以及如果优化你页面的关键渲染路径。









