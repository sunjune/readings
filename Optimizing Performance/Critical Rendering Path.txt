Critical Rendering Path
关键渲染路径

Optimizing the critical rendering path is critical for improving performance of our pages: our goal is to prioritize and display the content that relates to the primary action the user wants to take on a page.
优化关键渲染对于提升我们的页面性能是很关键的：我们的目标是按最用户最关心的顺序显示页面内容。

Delivering a fast web experience requires a lot of work by the browser. Most of this work is hidden from us as web developers: we write the markup, and a nice looking page comes out on the screen. But how exactly does the browser go from consuming our HTML, CSS, and JavaScript to rendered pixels on the screen?
为了实现快速的页面体验需要由浏览器做大量的工作。这项工作的大部分对于我们web developer来说是看不到的：我们写下这些标记，而一个漂亮的页面就出现在屏幕上。但是浏览器到底是怎么把我们的HTML、CSS和JavaScript渲染成屏幕上的像素呢。

Optimizing for performance is all about understanding what happens in these intermediate steps between receiving the HTML, CSS, and JavaScript bytes and the required processing to turn them into rendered pixels - that’s the critical rendering path.
对性能的优化就是理解这个过程中中发生的一切，从接收到HTML、CSS和JavaScript到经过必需的运算来把它们转化成渲染过的像素 — 这就是关键渲染路径。

By optimizing the critical rendering path we can significantly improve the time to first render of our pages. Further, understanding the critical rendering path will also serve as a foundation for building well performing interactive applications. It turns out, the process for processing interactive updates is the same, just done in a continuous loop and ideally at 60 frames per second! However, let’s not get ahead of ourselves just yet. First, let’s take a quick, ground-up overview of how the browser goes about displaying a simple page.
通过优化关键渲染路径我们能大大提升首次渲染页面的用时。此外，对关键渲染路径的理解也将为建立良好性能的交互应用打好基础。其实，交互运算的更新过程也是这样的，只是理想情况下以每秒60帧的速度无限循环。当然了，现在还没到谈这个的时候。首先，让我们快速介绍一下浏览器是怎么显示一个简单页面的。

=======================================
Constructing the Object Model
构建对象模型
=======================================

Before the browser can render the page it needs to construct the DOM and CSSOM trees. As a result, we need to ensure that we deliver both the HTML and CSS to the browser as quickly as possible.
在浏览器能够渲染页面之前，它需要构建DOM和CSSOM树。也就是说，我们需要保证尽快把HTML和CSS提供给浏览器。

In this guide
本节内容

  ·Document Object Model (DOM)
  文档对象模型(DOM)
  ·CSS Object Model (CSSOM)
  CSS对象模型(CSSOM)

TL;DR
简而言之

  ·Bytes → characters → tokens → nodes → object model
  字节 → 字符 → 标记 → 节点 → 对象模型
  ·HTML markup is transformed into a Document Object Model (DOM), CSS markup is transformed into a CSS Object Model (CSSOM)
  HTML标记被转换成文档对象模型(DOM)，CSS标记被转换成CSS对象模型(CSSOM)
  ·DOM and CSSOM are independent data structures
  DOM和CSSOM都是独立的数据结构
  ·Chrome DevTools Timeline allows us to capture and inspect the construction and processing costs of DOM and CSSOM
  Chrome开发人员工具的时间轴让我们能捕捉并检查DOM和CSSOM的结构和运算开销

Document Object Model (DOM)
文档对象模型(DOM)

    <html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link href="style.css" rel="stylesheet">
        <title>Critical Path</title>
      </head>
      <body>
        <p>Hello <span>web performance</span> students!</p>
        <div><img src="awesome-photo.jpg"></div>
      </body>
    </html>

Let’s start, with the simplest possible case: a plain HTML page with some text and a single image. What does the browser need to do to process this simple page?
让我们开始吧，用一个最简单的例子：一个只有一些文字和一张图片的简单HTML页面。浏览器要做些什么来处理这个简单的页面呢。

  01 Conversion: the browser reads the raw bytes of the HTML off the disk or network and translates them to individual characters based on specified encoding of the file (e.g. UTF-8).
  转换：浏览器从磁盘或网络中读到原始的HTML内容，并按照指定的编码把它们翻译成独立的字符。

  02 Tokenizing: the browser converts strings of characters into distinct tokens specified by the W3C HTML5 standard - e.g. “<html>”, “<body>” and other strings within the “angle brackets”. Each token has a special meaning and a set of rules.
  标记化：浏览器把字符组成的字符串转换成明确的由W3C HTML5标准指定的标记 - 例如<html>、<body>以及其他的放在尖括号里的字符串。每个标记都有一个特殊的含意和一套规则。
  03 Lexing: the emitted tokens are converted into “objects” which define their properties and rules.
  词法分析：解析出来的标记被转换成定义他们属性和规则的对象
  04 DOM construction: Finally, because the HTML markup defines relationships between different tags (some tags are contained within tags) the created objects are linked in a tree data structure that also captures the parent-child relationships defined in the original markup: HTML object is a parent of the body object, the body is a parent of the paragraph object, and so on.
  DOM结构：最终，因为HTML标记定义了不同标签之间的关系(一些标签包含别的标签)创建出来的对象链结到一个由原始标记定义的父子关系的树结构上：HTML对象是body的父对象，body是段落的父对象，等等。

The final output of this entire process is the Document Object Model, or the “DOM” of our simple page, which the browser uses for all further processing of the page.
整个运算的最终输出结束就是文档对象模型，或者我们这个简单页面的DOM，浏览器用来做页面所有其他的运算。

Every time the browser has to process HTML markup it has to step through all of the steps above: convert bytes to characters, identify tokens, convert tokens to nodes, and build the DOM tree. This entire process can take some time, especially if we have a large amount of HTML to process.
每次浏览器要处理HTML标记的时候它都得按上面所有的步骤进行一遍：把字节转换成字符、识别标记、把标记转换成节点、构建DOM树。这整个过程要花一些时间，特别是我们有大量的HTML要处理的时候。

Note
注意

We'll assume that you have basic familiarity with Chrome DevTools - i.e. you know how to capture a network waterfall, or record a timeline. If you need a quick refresher, check out the Chrome Developer Tools documentation, or if you're new to DevTools, I recommend taking the Codeschool Discover DevTools course.
我们假定你对Chrome开发工具有一定的了解 - 例如，你知道怎么捕捉网络请求或者记录一条时间轴。如果你需要一个快速入门，请查阅Chrome开发人员工具文档(https://developers.google.com/chrome-developer-tools/)，或者如果你从来没用过开发工具，我推荐Codeschool Discover DevTools课程(http://discover-devtools.codeschool.com/)。

If you open up Chrome DevTools and record a timeline while the page is loaded, you can see the actual time taken to perform this step — in example above, it took us ~5ms to convert a chunk of HTML bytes into a DOM tree. Of course, if the page was larger, as most pages are, this process might take significantly longer. You will see in our future sections on creating smooth animations that this can easily become your bottleneck if the browser has to process large amounts of HTML. That said, let’s not get ahead of ourselves…
如果你在页面加载的时候打开Chrome开发工具并记录一个时间轴，你会看到执行某一步的确切时间点 — 在上面的示例中，要花5ms把一块HTML字节转换成DOM树。当然了，如果页面非常大，就象大部分页面那样，这个过程可能会花长得多的时间。你会在将来的课程里看到创建平滑动画，那很容易成为你的瓶颈，如果浏览器得去处理大量的HTML的话。

With the DOM tree ready, do we have enough information to render the page to the screen? Not yet! The DOM tree captures the properties and relationships of the document markup, but it does not tell us anything about how the element should look when rendered. That’s the responsibility of the CSSOM, which we turn to next!
当DOM树准备好以后，我们有足够的信息来把页面渲染到屏幕了吗？还没呢！DOM树拿到了文档标记的属性和关系，但是它没有告诉我们要把那些元素渲染成什么样。这是CSSOM要干的事，接下来我们就要讲到了。

CSS Object Model (CSSOM)
CSS对象模型(CSSOM)

While the browser was constructing the DOM of our simple page, it encountered a link tag in the head section of the document referencing an external CSS stylesheet: style.css. Anticipating that it will need this resource to render the page, it immediately dispatches a request for this resource, which comes back with the following content:
在浏览器构造我们那个简单页面的DOM的时候，它在文档头部遇到一个link标签引用了一个外部的CSS样式：style.css。它预感会需要这个资源来渲染页面，所以就立即发起一个请求加载这个资源，下面就是返回的内容：

    body { font-size: 16px }
    p { font-weight: bold }
    span { color: red }
    p span { display: none }
    img { float: right }

Of course, we could have declared our styles directly within the HTML markup (inline), but keeping our CSS independent of HTML allows us to treat content and design as separate concerns: the designers can work on CSS, developers can focus on HTML, and so on.
当然，我们可以直接把HTML标记里(行内)声明样式，但是保持CSS独立于HTML之外有助于我们将内容与设计分别处理：设计师来做CSS，开发人员专注于HTML等等。

Just as with HTML, we need to convert the received CSS rules into something that the browser can understand and work with. Hence, once again, we repeat a very similar process as we did with HTML:
只针对HTML来说，我们需要把接收到的CSS规则转换成浏览器可以理解并工作的东西。因此，又一次，我们象处理HTML那样重复了一个非常简单的过程：

  字节 → 字符 → 标记 → 节点 → CSSOM

The CSS bytes are converted into characters, then to tokens and nodes, and finally are linked into a tree structure known as the “CSS Object Model”, or CSSOM for short:
CSS字节被转换成字符，然后是标记和节点，最终被链接到被称为“CSS 对象模型”的树结构上，或者简称为CSSOM：

Why does the CSSOM have a tree structure? When computing the final set of styles for any object on the page, the browser starts with the most general rule applicable to that node (e.g. if it is a child of body element, then all body styles apply) and then recursively refines the computed styles by applying more specific rules - i.e. the rules “cascade down”.
To make it more concrete, consider the CSSOM tree above. Any text contained within the span tag that is placed within the body element will have a font size of 16 pixels and have red text - the font-size directive cascades down from body to the span. However, if a span tag is child of a paragraph (p) tag, then its contents are not displayed.
为什么CSSOM会有树结构呢？在为页面上所有对象计算最终的样式时，浏览器启动该节点最常用的规则(例如，如果它是body的子元素，那么所有body的样式都会应用于它)然后通过应用更多特定规则来递归完善计算过的样式 — 例如，"cascade down"规则。再具体一点讲，考虑到上面的CSSOM树。包含在body元素中span标签里的任何文本都会是16像素的字体大小颜色是红色 — 字体大小的设置从body继承给span。然而，如果span标签是段落(p)的子元素，那么它的内容就不显示。

Also, note that the above tree is not the complete CSSOM tree and only shows the styles we decided to override in our stylesheet. Every browser provides a default set of styles also known as “user agent styles” – that’s what we see when we don’t provide any of our own – and our styles simply override these defaults (e.g. default IE styles). If you have ever inspected your “computed styles” in Chrome DevTools and wondered where all the styles are coming from, now you know!
要注意到上面的树不是完整的CSSOM树，而且只列出了我们决定重置样式表的那些样式。每个浏览器都提供了一套默认样式也被称为“用户代理样式” — 在没有任何自定义样式的时候我们所看到的 — 而我们的样式只是简单地覆盖了这些默认值(例如默认的IE样式)。如果你曾在Chrome的开发工具中检查过“计算过的样式”并且奇怪这些样式都是从哪来的，现在你就知道了。

Curious to know how long the CSS processing took? Record a timeline in DevTools and look for “Recalculate Style” event: unlike DOM parsing, the timeline doesn’t show a separate “Parse CSS” entry, and instead captures parsing and CSSOM tree construction, plus the recursive calculation of computed styles under this one event.
想知道CSS计算需要多长时间吗？在开发工具中记录一个时间线并查找“重算样式”事件：与DOM的解析不同，时间线上不会显示一个独立的“解析CSS”分支，而且不捕获解析和CSSOM构造，加上这个事件中的计算过的样式的递归运算。

Our trivial stylesheet takes ~0.6ms to process and affects 8 elements on the page – not much, but once again, not free. However, where did the 8 elements come from? The CSSOM and DOM and are independent data structures! Turns out, the browser is hiding an important step. Next, lets talk about the render tree that links the DOM and CSSOM together.
我们那点无关紧要的样式表用了大约0.6ms来计算并影响了8个元素 – 不是很多，但是再说一次，这是要花时间的。然而，这8个元素是哪来的？CSSOM和DOM和独立数据结构！这说明，浏览器隐藏了一个重要步骤。接下来，让我们谈谈把DOM和CSSOM联结起来的渲染树。


===============================================
Render-tree construction, Layout, and Paint
渲染树结构、布局和绘制
===============================================

The CSSOM and DOM trees are combined into a render tree, which is then used to compute the layout of each visible element and serves as an input to the paint process which renders the pixels to screen. Optimizing each of these steps is critical to achieve optimal rendering performance.
CSSOM和DOM树被绑定成渲染树，然后被用来计算每个可视元素的布局并为绘制进程提供输入项，由它来向屏幕上渲染像素点。优化这里的每一步对于达成最佳渲染性能是很关键的。

In the previous section on constructing the object model, we built the DOM and the CSSOM trees based on the HTML and CSS input. However, both of these are independent objects which capture different aspects of the document: one describes the content and the other the style rules that need to be applied to the document. How do we merge the two and get the browser to render pixels on the screen?
在前面构建对象模型的章节，我们基于HTML和CSS构建了DOM和CSSOM树输入项。然而，所有这些都是反映document不同角度的独立对象：一个是对内容的描述另一个是需要应用于document的样式规则。我们要如何合并这两者并让浏览器在屏幕上渲染像素点呢？

TL;DR
简而言之

  ·The DOM and CSSOM trees are combined to form the render tree
  DOM和CSSOM被结合来构成渲染树
  ·Render tree contains only the nodes required to render the page
  渲染树只包含需要用于渲染页面的节点
  ·Layout computes the exact position and size of each object
  布局计算每个对象最急需的位置和大小
  ·Paint is the last step that takes in the final render tree and renders the pixels to the screen
  绘制是最后一步，得到最终的渲染树并在屏幕上渲染像素点

The first step is for the browser to combine the DOM and CSSOM into a “render tree” that captures all the visible DOM content on the page, plus all the CSSOM style information for each node.
浏览器把DOM和CSSOM结合成渲染树的第一步，就是拿到页面上所有可视的DOM内容，给每个节点加总CSSOM样式信息。

To construct the render tree, the browser roughly does the following:
为了构建渲染树，浏览器大致要做以下事项：

  01 Starting at the root of the DOM tree, traverse each visible node.
  从DOM树的根开始，遍历所有可视节点
    ·Some nodes are not visible at all (e.g. script tags, meta tags, and so on), and are omitted since they are not reflected in the rendered output.
    有些节点根据不可见(例如，script标签、meta标签等等)，且因为它们不在渲染输入项中而被略去
    ·Some nodes are hidden via CSS and are also omitted from the render tree - e.g. the span node in example above is missing from the render tree because we have an explicit rule that sets “display: none” property on it.
    有些节点被CSS隐藏并且也从渲染树中略去 — 例如，上面示例中的span节点也在渲染树中被忽略因为我们给它加了“display: none”属性。
  02 For each visible node find the appropriate matching CSSOM rules and apply them.
  对于每个可视节点，找到合适匹配CSSOM规则并应用给它们
  03 Emit visible nodes with content and their computed styles.
  放出可带内容的可视节点以及它们计算过的样式


Remember
切记

  ·As a brief aside, note that 'visibility: hidden' is different from 'display: none'. The former makes the element invisible, but the element is still occupies space in the layout (i.e. it's rendered as an empty box), whereas the latter (display: none) removes the element entirely from the render tree such that the element is invisible and is not part of layout.
  简单插一句，请注意'visibility: hidden'和'display: none'是不同的。前者使得元素不可见，但是元素依然占用着布局的空间(换句话说，它是当成一个空的容器来渲染的)，但是后者(display: none)从渲染树中整个移除了元素所以元素不可见且不是布局中的一部分。


The final output is a render that contains both the content and the style information of all the visible content on the screen - we’re getting close! With the render tree in place, we can proceed to the “layout” stage.
最终输出的是包含了屏幕上所有可见内容和样式信息的渲染 — 我们就要完成了。有了在适当位置的渲染树，我们就能前进到“布局”的阶段了。

Up to this point we’ve calculated which nodes should be visible and their computed styles, but we have not calculated their exact position and size within the viewport of the device - that’s the “layout” stage, also sometimes known as “reflow.”
直到这时我们已经计算了那些可见的节点以及它们计算过的样式，但是我们还没计算在设备的可视屏显中它们确切的位置和大小 — 这就是“布局”阶段，有时候也被称为“流回”。

To figure out the exact size and position of each object the browser begins at the root of the render tree and traverses it to compute the geometry of each object on the page. Let’s consider a simple hands-on example:
要算出每个对象确切的大小和位置，浏览器从渲染树的根开始来遍历并计算页面中每个对象的几何形状。我们来动手写一个简单示例：

    <html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <title>Critial Path: Hello world!</title>
      </head>
      <body>
        <div style="width: 50%">
          <div style="width: 50%">Hello world!</div>
        </div>
      </body>
    </html>

The body of the above page contains two nested div’s: the first (parent) div sets the display size of the node to 50% of the viewport width, and the second div contained by the parent sets its width to be 50% of its parent - i.e. 25% of the viewport width!
上述页面的body中包含了两个嵌套的div：第一个(父)div设置了节点显示大小为可视屏显宽度的50%，被父节点包含的第二个div设置宽度为父节点宽度的50% — 也就是可视屏显宽度的25%。

The output of the layout process is a “box model” which precisely captures the exact position and size of each element within the viewport: all of the relative measures are converted to absolute pixels positions on the screen, and so on.
布局运算的输出结果是“盒模型”，它得到了可视屏显中每个元素的确切位置和大小：所有的相对尺寸都被转换成了屏幕上绝对坐标像素点，等等。

Finally, now that we know which nodes are visible, their computed styles, and geometry, we can finally pass this information to our final stage which will convert each node in the render tree to actual pixels on the screen - this step is often referred to as “painting” or “rasterizing.”
最后，现在我们知道有哪些可见的节点、它们计算过的样式、几何形状，我们最终能够将该信息传给最后的阶段，把渲染树里的每个节点转换成实际屏幕上的像素点 — 这个步骤经常显示成“绘制”或者“光栅化”。

Did you follow all of that? Each of these steps requires a non-trivial amount of work by the browser, which also means that it can often take quite a bit of time. Thankfully, Chrome DevTools can help us get some insight into all three of the stages we’ve described above. Let’s examine the layout stage for our original “hello world” example:
你曾跟踪过所有这些步骤吗？这里的每一步都要由浏览器完成一定量的工作，也就意味着通常要花一点时间。幸好，Chrome的开发工具能够帮助我们对上述三个阶段获得一些直观视图。让我们来检查一下我们那个“hello world”示例的布局阶段：

  ·The render tree construction and position and size calculation are captured with the “Layout” event in the Timeline.
  时间线中，渲染树结构和以及位置和大小的运算被集合在“布局”事件中。
  ·Once layout is complete, the browser issues a “Paint Setup” and “Paint” events which convert the render tree to actual pixels on the screen.
  一旦布局结束，浏览器就会放出“绘制开始”和“绘制”事件，那就是把渲染树转换成屏幕上实际的像素点。

The time required to perform render tree construction, layout and paint will vary based on the size of the document, the applied styles, and of course, the device it is running on: the larger the document the more work the browser will have to do; the more complicated the styles are the more time will be consumed for painting also (e.g. a solid color is “cheap” to paint, and a drop shadow is much more “expensive” to compute and render).
用来处理渲染树结构、布局和绘制所需的时间，会因文档大小、应用的样式、当然还有运行在什么设备上而有所不同：文档越大浏览器要干的就越多、样式越复杂也就要花越多的时间来绘制(例如：纯色绘制起来很“便宜”，而阴影在运算和渲染的时候就“贵”得多了)。

Once all is said and done, our page is finally visible in the viewport - woohoo!
所说的这些都完成的时候，我们的页面就最终呈现在可视屏显中了。

Let’s do a quick recap of all the steps the browser went through:
让我们对浏览器做过的所有步骤做一个总结：

  01 Process HTML markup and build the DOM tree
  处理HTML标记并且建立DOM树
  02 Process CSS markup and build the CSSOM tree
  处理CSS标记并且建立CSSOM树
  03 Combine the DOM and CSSOM into a render tree
  将DOM和CSSOM结合成渲染树
  04 Run layout on the render tree to compute geometry of each node
  在渲染树的基础上生成布局,计算每个节点的形状
  05 Paint the individual nodes to the screen
  将单独的节点绘制到屏幕上

Our demo page may look very simple, but it requires quite a bit of work! Care to guess what would happen if the DOM, or CSSOM is modified? We would have to repeat the same process over again to figure out which pixels need to be re-rendered on the screen.
我们的示例页看起来非常简单，但是它也要做不少事。小心猜一下如果DOM或CSSOM被修改了会发生什么？我们得把同样的过程再做一遍来找到要在屏幕上重新渲染哪些像素点。

Optimizing the critical rendering path is the process of minimizing the total amount of time spent in steps 1 through 5 in the above sequence. Doing so enables us to render content to the screen as soon as possible and also to reduces the amount of time between screen updates after the initial render - i.e. achieve higher refresh rate for interactive content.
优化关键渲染路径就是将按上述顺序把步骤1到步骤5所要花费的时间最小化。这样做能让我们尽可能快的把内容渲染到屏幕上，而且减少在初始渲染后屏幕更新要花的时间 — 也就是说为交互内容实现更高的刷新率。


=======================================
Render Blocking CSS
阻止渲染的CSS
=======================================

By default CSS is treated as a render blocking resource, which means that the browser will hold rendering of any processed content until the CSSOM is constructed. Make sure to keep your CSS lean, deliver it as quickly as possible, and use media types and queries to unblock rendering.
默认状态下CSS被当成阻止渲染资源，这意味着浏览器将停止渲染任何处理过的内容直到CSSOM被建成。确保你的CSS简洁，尽可能快地分发出去，并且使用媒体类型和侦测来解锁渲染。

In the previous section we saw that the critical rendering path requires that we have both the DOM and the CSSOM to construct the render tree, which creates an important performance implication: both HTML and CSS are render blocking resources. The HTML is obvious, since without the DOM we would not have anything to render, but the CSS requirement may be less obvious. What would happen if we try to render a typical page without blocking rendering on CSS?
在前面的章节我们看到了关键渲染路径需要我们将DOM和CSSOM构建成渲染树，而这对性能产生重大影响：HTML和CSS都是渲染阻止资源。HTML很明显，因为没有DOM我们都不知道要渲染什么，但是CSS的需求就没那么明显。如果我们试图去渲染一个典型的没有CSS阻止渲染的页面会发生什么呢？

TL;DR
简而言之

  ·By default CSS is treated as a render blocking resource
  默认情况下CSS被当成阻止渲染资源
  ·Media types and media queries allow us to mark some CSS resources as non render blocking
  媒体类型和媒体侦测允许我们将一部分CSS资源标记成不阻止渲染
  ·All CSS resources, regardless of blocking or non-blocking behavior are downloaded by the browser
  所有CSS资源、不管是阻止或不阻止行为都会被浏览器下载

The above example, showing the NYTimes website with and without CSS, demonstrates why rendering is blocked until CSS is available - without CSS the page is effectively unusable. In fact, the experience on the right is often referred to as a “Flash of Unstyled Content” (FOUC). As a result, the browser will block rendering until it has both the DOM and the CSSOM.
上面示例，展示了NYTimes网站带或不带CSS的样子，表明了为何直到CSS可用之前渲染都是被阻止的 — 没有CSS页面事实上是没用的。

CSS is a render blocking resource, get it down to the client as soon and as quickly as possible to optimize the time to first render!
CSS是会阻止渲染的资源，要尽可能快地把它下载到客户端以优化首次渲染的时间。

However, what if we have some CSS styles that are only used under certain conditions, for example, when the page is being printed, or being projected onto a large monitor? It would be nice if we didn’t have to block rendering on these resources!
然而，假如我们有一些只用于某些条件的CSS样式呢，例如，当页面正在被打印或正要放在大屏幕上？如果我们不用阻止渲染这些资源那会很好啊。

CSS “media types” and “media queries” allow us to address these use-cases:
CSS中的“媒体类型”和“媒体侦测”允许我们定位这些用例：

<link href="style.css" rel="stylesheet">
<link href="print.css" rel="stylesheet" media="print">
<link href="other.css" rel="stylesheet" media="(min-width: 40em)">

A media query consists of a media type and zero or more expressions that check for the conditions of particular media features. For example, our first stylesheet declaration does not provide any media type or query, hence it will apply in all cases - that is to say, it is always render blocking. On the other hand, the second stylesheet will only apply when the content is being printed - perhaps you want to rearrange the layout, change the fonts, etc - and hence this stylesheet does not need to block the rendering of the page when it is first loaded. Finally, the last stylesheet declaration provides a “media query” which is executed by the browser: if the conditions match, the browser will block rendering until the stylesheet is downloaded and processed.
媒体侦测由媒体类型及检查特定媒体功能状态的表达式组成。例如，我们的第一个样式声明没有提供任何媒体类型或查询，因此它将应用到所有的情况 — 那就是说，它总是会阻止渲染。另一方面，第二个样式只应用于内容被打印的时候 — 或许你想重排布局、改变字体等等 — 因此这个样式在页面首次加载的时候不需要阻止渲染。至此，最后一个样式表明提供了一个由浏览器运行的“媒体侦测”：如果条件匹配，浏览器将阻止渲染直到样式被下载并处理。

By using media queries, our presentation can be tailored to specific use cases such as display vs. print, and also to dynamic conditions such as changes in screen orientation, resize events, and more. When declaring your stylesheet assets, pay close attention to the media type and queries, as they will have big performance impact on the critical rendering path!
通过使用媒体侦测，我们的演示能够为特殊使用情况做调整，例如显示或打印，也能适应动态情况比如改变屏幕方向、调整大小事件等。当声明你的样式时，一定要特别注意媒体类型和侦测，它们会对关键渲染路径带来很大的性能影响。

Let’s consider some hands-on examples:
我们来看几个实用的示例：

  <link href="style.css"    rel="stylesheet">
  <link href="style.css"    rel="stylesheet" media="screen">
  <link href="portrait.css" rel="stylesheet" media="orientation:portrait">
  <link href="print.css"    rel="stylesheet" media="print">

  ·The first declaration is render blocking and matches in all conditions.
  第一个会阻止渲染并且匹配所有条件。
  ·The second declaration is also render blocking: “screen” is the default type and if you don’t specify any type, it’s implicitly set to “screen”. Hence, the first and second declarations are actually equivalent.
  第二个也会阻止渲染：“screen”是默认类型，如果你不指定任何类型它就毫无疑问设置为“sreen”。因此，第一和第二个声明实际上是一样的。
  ·The third declaration has a dynamic media query which will be evaluated when the page is being loaded. Depending on the orientation of the device when the page is being loaded, portrait.css may or may not be render blocking.
  第三个声明有动态媒体侦测，在页面加载的时候会被参考。在页面加载的时候根据页面的方向，portrait.css可能不会阻止渲染。
  ·The last declaration is only applied when the page is being printed, hence it is not render blocking when the page is first loaded in the browser.
  最后一个声明只应用于页面被打印的时候，因此在浏览器首页加载的时候不会阻止渲染。

Finally, note that “render blocking” only refers to whether the browser will have to hold the initial rendering of the page on that resource. In either case, the CSS asset is still downloaded by the browser, albeit with a lower priority for non-blocking resources.
最后，请注意“渲染阻止”仅指浏览器是否在该资源上停止页面的初始化渲染。不管是不是阻止，CSS文件还是要被浏览器下载的，即使非阻止资源有一些优先级。

============================================
Adding Interactivity with JavaScript
用JavaScript加入交互功能
============================================

JavaScript allows us to modify just about every aspect of the page: content, styling, and its behavior to user interactions. However, JavaScript can also block DOM construction and delay when the page is rendered. Make your JavaScript async and eliminate any unnecessary JavaScript from the critical rendering path to deliver optimal performance.
JavaScript能让我们修改页面里的所有东西：内容、样式以及与用户交互的行为。然而，JavaScript也同样会阻止DOM的构造并在页面渲染时候卡住。使你的JavaScript异步运行并从关键渲染路径中减少所有不必要的脚本以提供最佳性能。

In this guide
本节主要内容

  ·Parser Blocking vs. Asynchronous JavaScript
  解析器的阻止与异步脚本

TL;DR
简而言之

  ·JavaScript can query and modify DOM and CSSOM
  JavaScript能查询并修改DOM和CSSOM
  ·JavaScript execution blocks on CSSOM
  JavaScript的执行会阻止CSSOM
  ·JavaScript blocks DOM construction unless explicitly declared as async
  JavaScript会阻止DOM的构建除非被显式声明为异步

JavaScript is a dynamic language that runs in the browser and allows us to alter just about every aspect of how the page behaves: we can modify content on the page by adding or removing elements from the DOM tree, we can modify the CSSOM properties of each element, we can handle user input, and much more. To illustrate this in action, let’s augment our previous “Hello World” example with a simple inline script:
JavaScript是一种运行在浏览器中的动态语言，能让我们修改页面所能做的一切：我们能通过在DOM树中添加或删除元素来修改页面的内容、我们能修改每个元素的CSSOM属性、我们能处理用户输入，很多很多。为了用行动说明这一点，让我们用一段简单的行内脚本改进一下前面的“Hello Word”示例。

    <html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link href="style.css" rel="stylesheet">
        <title>Critical Path: Script</title>
      </head>
      <body>
        <p>Hello <span>web performance</span> students!</p>
        <div><img src="awesome-photo.jpg"></div>
        <script>
          var span = document.getElementsByTagName('span')[0];
          span.textContent = 'interactive'; // change DOM text content
          span.style.display = 'inline';  // change CSSOM property
          // create a new element, style it, and append it to the DOM
          var loadTime = document.createElement('div');
          loadTime.textContent = 'You loaded this page on: ' + new Date();
          loadTime.style.color = 'blue';
          document.body.appendChild(loadTime);
        </script>
      </body>
    </html>

  ·JavaScript allows us to reach into the DOM and pull out the reference to the hidden span node - the node may not be visible in the render tree, but it’s still there in the DOM! Then, once we have the reference, we can change its text (via .textContent), and even override its calculated display style property from ‘none’ to ‘inline’. Once all is said and done, our page will now display “Hello interactive students!”.
  JavaScript能让我们伸入到DOM内部并且得到隐藏的span节点的引用 - 节点可能在渲染树中是不可见的，但它依然在DOM里。然后，一旦我们有了这个引用，我们就能改变它的文本(通过.textContent)，甚至将它计算过的显示样式属性从“none”改为“inline”。当所有这些都做完了，我们的页面现在将会显示“Hello interactive students!”。

  ·JavaScript also allows us to create, style, and append and remove new elements to the DOM. In fact, technically our entire page could be just one big JavaScript file which creates and styles the elements one by one - that would work, but working with HTML and CSS is much easier in practice. In the second part of our JavaScript function we create a new div element, set its text content, style it, and append it to the body.
  JavaScript也能让我们在DOM中创建、加样式以及添加和移除新的元素。实际上，从技术上来说我们整个页面都可以只是一个大的JavaScript文件，它创建元素并给它们一个一个加样式 - 那是可行的，但是在实际工作中用HTML和CSS就简单多了。在我们的JavaScript函数的第二部分我们创建了一个新的div元素，设置了它的文本内容、给它加了样式并添加到body中。

With that, we’ve modified the content and the CSS style of an existing DOM node, and added an entirely new node to the document. Our page won’t win any design awards, but it illustrates the power and flexibility that JavaScript affords us.
However, there is a big performance caveat lurking underneath. JavaScript affords us a lot of power, but it also creates a lot of additional limitations on how and when the page is rendered.
通过这些，我们修改了一个已有的DOM节点的内容和CSS样式，并且添加了一全新的节点到document。我们的页面不会获得任何设计奖项，但是它展示了JavaScript的强大和灵活性。然面，这里面有很大的性能隐患。JavaScript给了我们强大的力量，但是也带来了许多其他的限制，在页面渲染的时机和方式上。

First, notice that in the above example our inline script is near the bottom of the page. Why? Well, you should try it yourself, but if we move the script above the span element, you’ll notice that the script will fail and complain that it cannot find a reference to any span elements in the document - i.e. getElementsByTagName(‘span’) will return null. This demonstrates an important property: our script is executed at the exact point where it is inserted in the document. When the HTML parser encounters a script tag, it pauses its process of constructing the DOM and yields control over to the JavaScript engine; once the JavaScript engine has finished running, the browser then picks up from where it left off and resumes the DOM construction.
首先，请注意在上面的示例中我们的行内Script是靠近页面底部的。为什么？你应该自己去试一下，但是如果我们把脚本移到span元素上面，你将发现脚本执行失败并且给出的错误提示是它在document中找不到任何span的引用 - 也就是说getElementByTagName('span')返回null。这表明一个重要的属性：我们的脚本是在它所在的文档中的位置处执行的。当HTML解析器遇到script标签，它就暂停它构造DOM的进程并将控制权交给JavaScript引擎；到JavaScript引擎结束运行，浏览器再从它停下的地方继续运行并恢复构建DOM。

In other words, our script block can’t find any elements later in the page because they haven’t been processed yet! Or, put slightly differently: executing our inline script blocks DOM construction, which will also delay the initial render.
Another subtle property of introducing scripts into our page is that they can read and modify not just the DOM, but also the CSSOM properties. In fact, that’s exactly what we’re doing in our example when we change the display property of the span element from none to inline. The end result? We now have a race condition.
换句话说，我们的脚本块不能找到在它后面出现的任何元素，因为它们还没被处理呢。或者再说得不一样一点：执行我们的行内脚本阻止了DOM的构建，这也会推迟初始渲染。另一个将脚本引入页面和细微属性是，它们能读写的不只是DOM，也可以是CSSOM属性。实际上，那就是我们在示例中所做的，当我们改变span的display属性由none改为inline的时候。结果是啥，我们现在有个比赛条件(?)。

What if the browser hasn’t finished downloading and building the CSSOM when we want to run our script? The answer is simple and not very good for performance: the browser will delay script execution until it has finished downloading and constructing the CSSOM, and while we’re waiting, the DOM construction is also blocked!
当我们想要运行脚本的时候浏览器没有结束下载和构造CSSOM时会怎么样？答案很简单而且对性能不太好：浏览器会延后脚本的运行直到CSSOM下载和构造完成，在我们等待的时候，DOM构建依然被阻止着。

In short, JavaScript introduces a lot of new dependencies between the DOM, CSSOM, and JavaScript execution and can lead to significant delays in how quickly the browser can process and render our page on the screen:
总之，JavaScript在DOM和CSSOM以及JavaScript的运行之间引入了大量新的依赖性，这会对浏览器将页面渲染到屏幕上能有多快产生很大的延迟。

  ·The location of the script in the document is significant
  脚本在document中的位置是很重要的
  ·DOM construction is paused when a script tag is encountered and until the script has finished executing
  当遇到script标签后直到脚本结束运行DOM构建都是被暂停的
  ·JavaScript can query and modify the DOM and CSSOM
  JavaScript能查询和修改DOM和CSSOM
  ·JavaScript execution is delayed until the CSSOM is ready
  JavaScript的运行会被延迟直到CSSOM准备好

When we talk about “optimizing the critical rendering path,” to a large degree we’re talking about understanding and optimizing the dependency graph between HTML, CSS, and JavaScript.
当我们讨论“优化关键渲染路径”的时候，很大程度上我们是在讨论理解和优化HTML、CSS以及JavaScript之间的依赖。

Parser Blocking vs. Asynchronous JavaScript
解析器阻止和异步JavaScript

By default, JavaScript execution is “parser blocking”: when the browser encounters a script in the document it must pause DOM construction, hand over the control to the JavaScript runtime and let the script execute before proceeding with DOM construction. We already saw this in action with an inline script in our earlier example. In fact, inline scripts are always parser blocking unless you take special care and write additional code to defer their execution.
默认状态下，JavaScript运行是“解析器阻止”：当浏览器在document中遇到脚本它必须暂停DOM构建，将控制权交给JavaScript运行时并让脚本运行先于DOM构建的进程。我们已经前面示例的行内脚本看到了在运行。实际上，行内脚本总是解析器阻止的，除非你特别注意并写一些其他的代码来推迟其运行。

What about scripts included via a script tag? Let’s take our previous example and extract our code into a separate file:
把脚本包含在script标签里面怎么样？让我们把前面例子中代码放到一个单独的文件中：

<html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link href="style.css" rel="stylesheet">
        <title>Critical Path: Script External</title>
      </head>
      <body>
        <p>Hello <span>web performance</span> students!</p>
        <div><img src="awesome-photo.jpg"></div>
        <script src="app.js"></script>
      </body>
    </html>

app.js
    var span = document.getElementsByTagName('span')[0];
    span.textContent = 'interactive'; // change DOM text content
    span.style.display = 'inline';  // change CSSOM property
    // create a new element, style it, and append it to the DOM
    var loadTime = document.createElement('div');
    loadTime.textContent = 'You loaded this page on: ' + new Date();
    loadTime.style.color = 'blue';
    document.body.appendChild(loadTime);

Would you expect the execution order to be any different when we use a <script> tag instead of using an inline JavaScript snippet? Of course, the answer is “no” as they are identical and should behave in the same way. In both cases the browser will have to pause and execute the script before it can process the remainder of the document. However, in the case of an external JavaScript file the browser will also have to pause and wait for the script to be fetched from disk, cache, or a remote server, which can add tens to thousands of milliseconds of delay to the critical rendering path.
当我们使用<script>而不是用行内JavaScript代码段后你会期望执行顺序有一些不同吗？当然，答案是“不会”因为它们是一样的并会有相同的行为。这两种情况下浏览器都得剩下的文档处理停下来先运行脚本。然而，在有一个外部JavaScript文件的情况下浏览器还停下等着脚本从磁盘、缓存以及远端服务器上拿到，这会给关键渲染路径增加数十到数千毫秒。

That said, good news, we do have an escape hatch! By default all JavaScript is parser blocking and the browser doesn’t know what the script is planning to do on the page, hence it has to assume the worst case scenario and block the parser. However, what if we could signal to the browser and tell it that the script does not need to be executed at the exact point where it is referenced in the document? Doing so would allow the browser to continue to construct the DOM and let the script execute once it’s ready - e.g. once the file has been fetched from cache or a remote server.
那是说，好消息，我们有一个逃生出口。默认情况下JavaScript是解析器阻止的而且浏览器不知道脚本要在页面上做什么，因此它只得假设最坏的方案并阻止解析器。然而，如果我们能给浏览器个信号告诉它脚本不需要在它所在的位置立即运行会怎样？这样做的话就能让浏览器继续构建DOM并在它准备好的时候让脚本运行 - 例如，当文件从缓存远端服务器上拿到的时候。

So, how do we achieve this trick? It’s pretty simple, we can mark our script as async:
那么，我们怎么来实现呢？很简单，我们可以把脚本标记为异步的：

  <html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link href="style.css" rel="stylesheet">
        <title>Critical Path: Script Async</title>
      </head>
      <body>
        <p>Hello <span>web performance</span> students!</p>
        <div><img src="awesome-photo.jpg"></div>
        <script src="app.js" async></script>
      </body>
    </html>

Adding the async keyword to the script tag tells the browser that it should not block the DOM construction while it waits for the script to become available - this is a huge performance win!
给script标签加上async关键词告诉浏览器不用在等着脚本可用的时候阻止DOM构建 - 这会带来很大的性能提升！

===================================================================
Measuring the Critical Rendering Path with Navigation Timing
用Navigation Timing来测量关键渲染路径
===================================================================

You can't optimize what you can't measure. Thankfully, the Navigation Timing API gives us all the necessary tools to measure each step of the critical rendering path!
没法测量的东西就没办法优化。幸亏，Navigation Timing API给了我们所有必须的工具来测试关键渲染路径的每一个步骤！

TL;DR
简而言之

  ·Navigation Timing provides high resolution timestamps for measuring CRP
  Navigation Timing对于测量CRP给了高精度的时间戳
  ·Browser emits series of consumable events which capture various stages of the CRP
  浏览器会给出一系列可用的事件来捕获CRP的各种阶段

The foundation of every solid performance strategy is good measurement and instrumentation. Turns out, that is exactly what the Navigation Timing API provides.
可靠的性能策略的基础是好的测量和仪表。原来，这正是Navigation Timing API所能提供的。

Each of the labels in the above diagram corresponds to a high resolution timestamp that the browser tracks for each and every page it loads. In fact, in this specific case we’re only showing a fraction of all the different timestamps — for now we’re skipping all network related timestamps, but we’ll come back to them in a future lesson.
上图中每个标签都相当于一个高精度的时间戳，那是浏览器加载每个页面时的轨迹。实际上，在这个特定的情况下我们只能展示一小部分时间戳 — 我们会略过所有网络相关的时间戳，不过在将来的课程里我们会讲到它们。

So, what do these timestamps mean?
那么，这些时间戳都是啥意思？

  ·domLoading: this is the starting timestamp of the entire process, the browser is about to start parsing the first received bytes of the HTML document.
  这是整个进程的起始时间戳，浏览器要准备开始解析HTML文档的最先收到的字节了。
  ·domInteractive: marks the point when the browser has finished parsing all of the HTML and DOM construction is complete.
  这个点是标记着浏览器已经结束解析所有的HTML而DOM构建已经结束。
  ·domContentLoaded: marks the point when both the DOM is ready and there are no stylesheets that are blocking JavaScript execution - meaning we can now (potentially) construct the render tree.
  这个点是标记着DOM已经准备好而且没有样式表阻止着JavaScript运行 - 意味着我们现在可能构建渲染树了。
    ·Many JavaScript frameworks wait for this event before they start executing their own logic. For this reason the browser captures the EventStart and EventEnd timestamps to allow us to track how long this execution took.
    许多JavaScript框架等着这个事件，之后它们才开始运行它们自己的逻辑。由于这个原因浏览器捕获EventStart和EventEnd时间戳让我们能跟踪这次运行要花多长时间。
  ·domComplete: as the name implies, all of the processing is complete and all of the resources on the page (images, etc.) have finished downloading - i.e. the loading spinner has stopped spinning.
  就象名字提示的那样，所有的运算都结束了而且页面里所有的资源(图片等)都完成下载 - 也就是说加载完成了。
  ·loadEvent: as a final step in every page load the browser fires an “onload” event which can trigger additional application logic.
  作为每个页面加载的最后一步浏览器放出一个“onload”事件来触发其他应用的逻辑。

























Udacity course
Udacity课程

Interested in taking a deep dive into the Critical Rendering Path? Check out or companion course and learn how the browser converts HTML, CSS, and JavaScript to pixels on the screen, how to use DevTools to measure performance, and how to optimize the Critical Rendering Path of your pages.
对关键渲染路径有兴趣再深入一些？请查阅合作课程理解浏览器是如何把HTML、CSS和JavaScript转换成屏幕上的像素，如何使用开发工具来测量性能，以及如果优化你页面的关键渲染路径。









