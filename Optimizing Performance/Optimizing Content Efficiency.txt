Optimizing Content Efficiency
优化内容效率

Our web applications continue to grow in their scope, ambition, and functionality - that's a good thing. However, the relentless march towards a richer web is driving another trend: the amount of data downloaded by each application continues to increase at a steady pace. To deliver great performance we need to optimize delivery of each and every byte of data!
我们的web应用持续增长着它们的范围、雄心和功能 - 这是件好事。然而，这种无情的向富web迈进带来了另一个趋势：每个应用要下载的数据总量稳定持续增长。要提供更好的性能我们需要对每个字节的数据进行优化。

What does a modern web application look like? HTTP Archive can help us answer this question. The project tracks how the web is built by periodically crawling the most popular sites (300,000+ from the Alexa Top 1M list) and recording and aggregating analytics on the number resources, content types, and other metadata for each individual destination.
一个现代浏览器看上去是什么样的？HTTP Archive(http://httparchive.org/)能帮我们回答这个疑问。这个项目通过周期性地爬虫收集最流行的网站(Alexa前1百万名单中的30万以上)并对每个单独的目标记录和汇总分析资源数量、内容类型以及其他的元数据。

The above data captures the trend in growth of number of downloaded bytes for popular destinations on the web between January 2013 and January 2014. Of course, not every site grows at the same rate or requires the same amount of data, hence the reason why we are highlighting the different quantiles within the distribution: 50th (median), 75th, and 90th.
上面的数据获取的是2013年1月到2014年1月之间流行网站被下载的总字节数的增长趋势。当然了，不是每个网站都以这种速率增长或请求同样的数据量，这就是为什么我们高亮显示不同的百分比：第50(中值)、第75和第90。

A median site at the beginning of 2014 is composed of 75 requests that add up to 1054 KB of total transferred bytes, and the total number of bytes (and requests) has grown at a steady pace throughout the previous year. This by itself should not be all that surprising, but it does carry important performance implications: yes, internet speeds are getting faster, but they are getting faster at different rates in different countries, and many users are still subject to data caps and expensive metered plans - especially on mobile.
2014年初的中值站点有75次合计达到1054KB的传输字节，而且过去一年字节总数(以及请求数)稳步增长。就它本身来说这没什么好吃惊的，但它带着重要的性能影响：是的，网速越来越快，但在不同的国家变快的速率不同，而且很多用户仍然受制于数据上限和昂贵的流量计划 - 特别是在移动端。

Unlike their desktop counterparts, web applications do not require a separate installation process: enter the URL and we are up and running – that’s a key feature of the web. However, to make this happen we often have to fetch dozens, and sometime hundreds, of various resources, all of which can add up to megabytes of data and must come together in hundreds of milliseconds to facilitate the instant web experience we are aiming for.
与桌面应用不同的是，web应用不用单独安装：进入URL我们就启动运行了 - 这是网站的主要特色。然而，要实现这个我们通常要取得数十甚至数百的各种资源，合计达到数M字节的数据，而且必须在几百毫秒内把它们汇集到一起来让我们目标中的迅捷网站体验成为现实。

Achieving an instant web experience in light of these requirements is no small feat, which is why optimizing content efficiency is critical: eliminating unnecessary downloads, optimizing transfer encoding of each resource through various compression techniques, and leveraging caching whenever possible to eliminate redundant downloads.
在这么多的请求下要达到迅捷网站体验可是个不小的壮举，这就是为什么优化内容效率是很关键的：去掉不必须的下载、通过多种压缩技术对每种资源进行优化传输编码、只要有可能就借助缓存来减少多余的下载。

=====================================
Eliminating unnecessary downloads
去掉不必要的下载
=====================================

The fastest and best optimized resource is a resource not sent. Have you audited your resources recently? You should, and you should do so periodically to ensure that each resource is helping deliver a better user experience.
最快最优化的资源就是没有发送出去的资源。你最近审计过你的资源吗？你应该，而且应该定期确认每个资源都有助于提供更好的用户体验。

TL;DR
简而言之

  ·Inventory all own and third party assets on your pages
  清点你页面上所有自主和第三方的资源
  ·Measure the performance of each asset: its value and its technical performance
  测量每个资源的性能：它的重要性和它的技术性能
  ·Determine if the resources are providing sufficient value
  确定这些资源是否提供足够的价值

In this guide
本节主要内容

The fastest and best optimized resource is a resource not sent. Of course, this may seem like an obvious statement, but in practice it is all too often overlooked: as a performance engineer, it is your job to always maintain a critical eye for any opportunity to eliminate unnecessary resources from your application. It’s a good practice to question, and periodically revisit, the implicit and explicit assumptions with your team. A few examples:
最快速最佳的资源就是没有发出去的资源。当然，这可能看起来像是个很明显的说法，但在实际中它常常被忽略：作为一个高性能工程师，总是保持挑剔的眼光抓住任何机会从你的应用中剔除那些不必要的资源就是你的工作。好的练习包括提问、周期性地重复访问、与你的团队暗示或明确地假设。举例如下：
  
  ·We’ve always included resource X on our pages, but does the cost of downloading and displaying it offset the value it delivers to the user? Can we measure and prove its value?
  我们总是包含着一个资源X在我们的页面上，但是下载并显示它的开销能补偿它带给用户的价值吗？我们能测定并证明它的价值吗？
  ·Does the resource — especially if it is a third-party resource — deliver consistent performance? Is this resource in the critical path, or need to be? If the resource is in the critical path, could it be a single point of failure for our site - i.e. if the resource is unavailable, will it affect performance and the user experience of our pages?
  这个资源 — 特别是如果是个第三方资源 — 能保持稳定的性能吗？这个资源在关键路径里吗，或者说需要在吗？如果资源是关键路径里的，它会成为我们网站失败的单点吗？ - 换句话说，如果资源不可用，它会影响我们页面的性能和用户体验吗？
  ·Does this resource need or have an SLA? Does this resource follow performance best practices: compression, caching, and so on?
  资源需要或已经有SLA(服务等级协议)了吗？资源遵从性能最佳实践了吗：压缩、缓存等等？
  
All too frequently our pages contain resources which are unnecessary, or worse, hinder page performance without delivering much value to the visitor or the site they are hosted on. This applies equally to first-party and third-party resources and widgets:
我们的页面包含太多不必要的资源，或者更糟的，阻碍了页面性能且没有提供更多价值给访问者或它们所在的网站。这同样适用于第一方和第三方资源和小部件：

  ·Site A has decided to display a photo carousel on its homepage to allow the visitor to preview multiple photos with a quick click — all the photos are loaded when the page is loaded, and photos are advanced by the user.
  站点A决定在首页显示一个照片轮播，允许用户通过快速点击来预览多个照片 — 当页面加载的时候所有图片都被加载了，而且照片被用户提高。
    ·Question: have you measured how many users view multiple photos in the carousel? You could be incurring high overhead by downloading unnecessary resources which are never viewed by most visitors.
    问题：你测量过有多少用户在轮播里看多张照片吗？你会招致过多非必要资源的下载流量，而大部分访问者从来都没看过。
  ·Site B has decided to install a third-party widget to display related content, improve social engagement, or provide some other service.
  站点B决定安装一个第三方小部件来显示相关内容，提升社交参与度，或者提供一些其他服务。
    ·Question: have you tracked how many visitors use the widget or click-through on the content provided by the widget? Is the engagement generated by this widget enough to justify its overhead?
    问题：你跟踪过有多少访问者使用了小部件或从它提供的内容上点击了吗？部件所产生的参与度与它的消耗对等吗？

As you can see, while eliminating unnecessary downloads seems like a trivial statement, in practice it is anything but, as it often requires a lot careful thinking and measurement to make the call. In fact, for best results you should periodically inventory and revisit these questions for each and every asset on your pages.
就像你看到的，虽然去除不必要的下载看上去是琐碎的说法，但实际上它是任何事，因为它经常需要大量的认真思考和测量来最终实施。事实上，为了最佳结果，你应该定期盘点页面上的东西并重新审视这些问题。

============================================================
Optimizing encoding and transfer size of text-based assets
优化基于文本的编码和传输大小
============================================================

Our web applications continue to grow in their scope, ambition, and functionality - that's a good thing. However, the relentless march towards a richer web is driving another trend: the amount of data downloaded by each application continues to increase at a steady pace. To deliver great performance we need to optimize delivery of each and every byte of data!
我们的web应用持续增长着它们的范围、雄心和功能 - 这是件好事。然而，这种无情的向富web迈进带来了另一个趋势：每个应用要下载的数据总量稳定持续增长。要提供更好的性能我们需要对每个字节的数据进行优化。

In this guide
本节主要内容

  ·Data compression 101
  数据压缩101
  ·Minification: preprocessing & context-specific optimizations
  最小化：预压缩和上下文指定优化
  ·Text compression with GZIP
  用GZIP压缩文本

Data compression 101
数据压缩101

Once we’ve eliminated any unnecessary resources, the next step is to minimize the total size of the remaining resources the browser has to download - i.e. compress them. Depending on the resource type - text, images, fonts, and so on - we have a number of different techniques at our disposal: generic tools that can be enabled on the server, pre-processing optimizations for specific content-types, and resource specific optimizations that require input from the developer.
Delivering the best performance requires the combination of all of these techniques.
一旦我们去除了不必要的资源，下一步就是最小化浏览器要下载的其余资源总大小了 - 也就是，压缩它们。根据资源类型 - 文本、图片、字体等等 - 我们有大量不同的技术供支配：一般的可以在服务器端启用的工具、对指定内容类型的预压缩优化以及需要由开发者输入的资源特定优化。为达到最佳性能要对所有这些技术综合利用。

TL;DR
简而言之

  ·Compression is the process of encoding information using fewer bits
  压缩就是用更少的数据把信息编码的过程
  ·Eliminating unnecessary data always yields the best results
  去掉不必要的数据总是能达成最好的结果
  ·There are many different compression techniques and algorithms
  有很多种不同的压缩技术和算法
  ·You will need a variety of techniques to achieve the best compression
  你将需要不同的技术来实现最佳压缩率

The process of reducing the size of data is known as “data compression,” and it is a deep field of study on its own: many people have spent their entire careers working on algorithms, techniques, and optimizations to improve compression ratios, speed, and memory requirements of various compressors. Needless to say, a full discussion on this topic is out of our scope, but it is still important to understand, at a high level, how compression works and the techniques we have at our disposal to reduce the size of various assets required by our pages.
减少数据大小的处理过程被称为“数据压缩”，而且是一个很深的自行研究领域：很多人终其全部的职业生涯致力于研究各种压缩算法、技术以及优化并提升压缩比、速度和内存占用。就不展开说了，关于这个话题的讨论超出了我们的范围，但是对压缩如何进行以及我们减少页面所需的各项内容的大小所用到的技术的有高一点的理解是很重要的。

To illustrate the core principles of these techniques in action, let’s consider how we can go about optimizing a simple text message format that we’ll invent just for this example:
为了用实例说明这些技术的核心原理，让我们想一下如何优化一段简单的文本消息格式，只是为这个示例而发明的：

# Below is a secret message, which consists of a set of headers in
# key-value format followed by a newline and the encrypted message.
下面是一段秘密消息，由key-value格式的报头跟随着新起的一行以及加密的消息组成。
format: secret-cipher
date: 04/04/14
AAAZZBBBBEEEMMM EEETTTAAA

  01 Messages may contain arbitrary annotations, which are indicated by the “#” prefix. Annotations do not affect the meaning or any other behavior of the message.
  消息可能包含一些以“#”前缀标识的注释。注释不会影响消息的含意或其他行为。
  02 Messages may contain “headers” which are key-value pairs (separated by “:”) and have to appear at the beginning at the message.
  消息可能会包含“报头”，由key-value对(以“:”分隔)而且一定要出现在消息最开始的地方。
  03 Messages carry text payloads.
  消息携带文本内容。

What could we do reduce the size of the above message, which is currently 200 characters long?
我们能做点什么来减少上面有200个字符的消息体积呢？

  01 Well, the comment is interesting, but we know that it doesn’t actually affect the meaning of the message, so we eliminate it when we’re transmitting the message.
  注释挺有意思的，但是我们知道实际上它并不影响消息的含意，那么我们在传送消息的时候就把它去掉了。
  02 There are probably some clever techniques we could use to encode headers in an efficient manner – e.g. we don’t know if all messages always have “format” and “date”, but if they did, we could convert those to short integer IDs and just send those! That said, we’re not sure if that’s the case, so we’ll leave it alone for now.
  可能有一些聪明的技术手段让我们能以一种高效的方式来给报头编码 - 例如，我们不知道是否所有的消息总是带有“format”和“date”，但是如果有，我们就能把它些转换成短的整数ID而且只要发送它们就行了！就是说，我们不确定是否是这样，所以就先把它放在一边吧。
  03 The payload is text only, and while we don’t know what the contents of it really are (apparently, it’s using a “secret-message”), just looking at the text seems to show that there is a lot of redundancy in it. Perhaps, instead of sending repeated letters, we can just count the number of repeated letters and encode them more efficiently?
  内容只是文本，而且我们不知道内容到底是什么(很明显，它使用的是“密文”)，只是看字面好像有很多重复。或许，不用发送重复的字符，我们只要数一下重复字符的个数并且编码会更有效？

E.g. “AAA” becomes “3A” - or, sequence of three A’s.
例如：“AAA”改成“3A” - 或者顺序的三个A。

Combining our techniques, we arrive at the following result:
联合我们的技术，我们得到如下结果：

format: secret-cipher
date: 04/04/14
3A2Z4B3E3M 3E3T3A

The new message is 56 characters long, which means we managed to compress our original message by an impressive 72% - not bad, all things considered, and we’re only getting started!
新的消息长度是56个字符，这意味着我们设法将原始消息压缩了72% - 不错，所有事情都考虑到了，而我们才刚刚开始！

Of course, you may be wondering, this is all great, but how does this help us optimize our web pages? Surely we’re not going to try to invent our compression algorithms, are we? The answer is no, we won’t, but as you will see, we will use the exact same techniques and way of thinking when optimizing various resources on our pages: preprocessing, context-specific optimizations, and different algorithms for different content.
当然，你可能会吃惊这太棒了，但是这怎么帮助我们优化我们的页面呢？我们确实没有想发明压缩算法，是吗？答案是否，我们不会那样做，但是你将会看到，我们在优化页面上的各种资源时将使用同样的技术和思路：预处理、上下文特征优化以及为不同的内容使用不同的算法。

Minification: preprocessing & context-specific optimizations
缩小倍数：预处理和上下文特征优化

TL;DR
简而言之

  ·Content-specific optimizations can significantly reduce the size of delivered resources.
  内容特征优化可以显著地减少交付资源的大小。
  ·Content-specific optimizations are best applied as part of your build/release cycle.
  内容特征优化最好应用于你的生产/发布循环。

The best way to compress redundant or unnecessary data is to eliminate it altogether. Of course, we can’t just delete arbitrary data, but in some contexts where we may have content-specific knowledge of the data format and its properties, it is often possible to significantly reduce the size of the payload without affecting its actual meaning.
压缩多余或不必要的数据最好的办法是完全去掉它们。当然了，我们不能仅仅随意删除数据，但是在一些环境中我们可能对数据格式与其属性的内容特征有所了解，通常可能会大大减少负载而不会影响其真实含意。

    <html>
      <head>
      <style>
         /* awesome-container is only used on the landing page */
         .awesome-container { font-size: 120% }
         .awesome-container { width: 50% }
      </style>
     </head>
    
     <body>
       <!-- awesome container content: START -->
        <div>…</div>
       <!-- awesome container content: END -->
       <script>
         awesomeAnalytics(); // beacon conversion metrics
       </script>
     </body>
    </html>

Consider the simple HTML page above and the three different content types that it contains: HTML markup, CSS styles, and JavaScript. Each of these content types has different rules for what constitutes valid HTML markup, CSS rules, or JavaScript content, different rules for indicating comments, and so on. How could we reduce the size of this page?
看一下上面这个简单的HTML页面，里面有三种不同的内容类型：HTML标记、CSS样式以及JavaScript。这每种内容类型都有不同的规则构成了有效的HTML标记、CSS规则或JavaScript内容，标识注释的不同规则，等等。

  ·Code comments are a developer’s best friend, but the browser does not need to see them! Simply stripping the CSS (/* … */), HTML (<!-- … -->), and JavaScript (// …) comments can significantly reduce the total size of the page.
  代码注释是开发人员最好的朋友，但是浏览器不用看它们！简单地剔除CSS(/*…*/)，HTML(<!-- … -->)以及JavaScript(// …)的注释能有效减少页面总大小。
  ·A “smart” CSS compressor could notice that we’re using an inefficient way of defining rules for ‘.awesome-container’ and collapse the two declarations into one without affecting any other styles, saving yet more bytes.
  聪明的CSS压缩器能注意到我们在‘.awesome-container’使用了效率差的定义规则的方式而将两个声明合并到一个里面而不会对样式有任何影响，同时也节省了更多字节。
  ·Whitespace (spaces and tabs) is a developer convenience in HTML, CSS, and JavaScript. An additional compressor could strip out all the tabs and spaces.
  空白(space和tab)是开发者在HTML、CSS和JavaScript中很有用的。有压缩工具可以剔除所有的tab和空白。

   <html><head><style>.awesome-container{font-size:120%;width: 50%}
    </style></head><body><div>…</div><script>awesomeAnalytics();
    </script></body></html>

After applying the above steps our page goes from 406 to 150 characters - 63% compression savings! Granted, it’s not very readable, but it also doesn’t have to be: we can keep the original page as our “development version” and then apply the steps above whenever we are ready to release the page on our website.
经过上述步骤我们的页面从406减少到150字符 - 压缩了63%！不过，它变得非常不易读，但也不是一定要这样：我们可以保存原始页面作为我们的“开发版”然后当准备发布页面到网站的时候再应用上述步骤。

Taking a step back, the above example illustrates an important point: a general purpose compressor - say one designed to compress arbitrary text - could probably also do a pretty good job of compressing the page above, but it would never know to strip the comments, collapse the CSS rules, or dozens of other content-specific optimizations. This is why preprocessing / minification / context-aware optimization can be such a powerful tool.
回头再看，上述示例说明了重要的一点：通常用途的压缩器 - 是说设计用于压缩随便哪种文本的 - 可能也能很好地用于压缩上述页面，但它永远也不知道去除注释、合并CSS规则或更多其他的内容特征优化。这就是为什么预处理/缩小率/上下文相关优化是如此强大的工具。

Remember
切记

Case in point, the uncompressed development version of the JQuery library is now approaching ~300KB. The same library, but minified (removed comments, etc.) is about 3x smaller: ~100KB.
注意一点，未压缩的JQuery库的开发版现在将近300KB。经过缩小同样的库(去除了注释等)大约小了3倍：100KB左右。

Similarly, above techniques can be extended beyond just text-based assets. Images, video, and other content types all contain their own forms of metadata and various payloads. For example, whenever you take a picture with a camera, the photo also typically embeds a lot of extra information: camera settings, location, and so on. Depending on your application, this data may be critical (e.g. a photo sharing site), or completely useless and you should consider whether it is worth removing. In practice, this metadata can add up to tens of kilobytes for every image!
同样的，上述技术也可扩展到文本内容以外。图片、视频以及其他内容类型都包含它们自己的元数据形式以及各种负载。比如，在你用相机拍了一张照片，照片也基本上会嵌入大量的附加信息：相机设定、地点等等。对你的应用来说，这些数据可能是关键的(例如照片分享网站)，或者根本没用而且你要考虑是否值得删除。实际上，每张图片中这些元数据总计能达到数十KB！

In short, as a first step in optimizing the efficiency of your assets, build an inventory of the different content types and consider what kinds of content-specific optimizations you can apply to reduce their size - doing so can yield significant savings! Then, once you’ve figured out what they are, automate these optimizations by adding them to your build and release processes - that’s the only way you can guarantee that the optimizations will stay in place.
总之，作为优化你的资产效能的第一步，对不同内容类型列一个清单并且考虑你能用哪种内容特征优化来减少它们的大小 - 做这些可以有显著的节省。接下来，一旦你已经找出它们，把这些优化做成自动化的并加入到你开发和发布流程中 - 这是保证优化能保持下来的惟一方法。

Text compression with GZIP
用GZIP压缩文本

TL;DR
简而言之

  ·GZIP performs best on text-based assets: CSS, JavaScript, HTML
  GZIP在文本资产上执行得最好：CSS、JavaScript和HTML。
  ·All modern browsers support GZIP compression and will automatically request it
  所有现代浏览器都支持GZIP压缩而且会自动请求它。
  ·Your server needs to configured to enable GZIP compression
  你的服务器需要配置以启用GZIP压缩。
  ·Some CDNs require special care to ensure that GZIP is enabled
  一些CDN要特别注意确保GZIP是启用的。

GZIP is a generic compressor that can be applied to any stream of bytes: under the hood it remembers some of the previously seen content and attempts to find and replace duplicate data fragments in an efficient way - for the curious, great low-level explanation of GZIP. However, in practice, GZIP performs best on text-based content, often achieving compression rates of as high as 70-90% for larger files, whereas running GZIP on assets that are already compressed via alternative algorithms (e.g. most image formats) yields little to no improvement.
GZIP是一种通用压缩器可以用于任何字节流：它会记住前面看过的内容并以高效的方式尝试查找重复数据碎片 - 如果有兴趣，请参阅(https://www.youtube.com/watch?v=whGwm0Lky2s&feature=youtu.be&t=14m11s)。然而，实际上GZIP在文本内容上运行得最好，对于大文件通常压缩比高达70-90%，但是对于已经用其他算法压缩过的内容资产(例如大部分图片格式)运行GZIP提高就很小甚至没有。

All modern browsers support and automatically negotiate GZIP compression for all HTTP requests: our job is to ensure that the server is properly configured to serve the compressed resource when requested by the client.
所有现代浏览器都支持并自动对所有的HTTP请求协商GZIP压缩：我们的工作就是确保服务器经过正确配置，被客户端请求的时候能提供压缩过的资源。

The above table illustrates the savings provided by GZIP compression for a few of the most popular JavaScript libraries and CSS frameworks. The savings range from 60 to 88%, and note that the combination of minified files (identified by “.min” in their filenames), plus GZIP, offers an even larger win.
上表说明了GZIP对一些最流行的JavaScript库和CSS框架压缩后能的缩减量。节省范围从60到88%，注意结合了缩小的文件(文件名中以“.min”标识的)，经过GZIP，甚至能有更大的节省。

  ·Apply content-specific optimizations first: CSS, JS, and HTML minifiers.
  首先使用内容特征优化：CSS、JS以及HTML瘦身器。
  ·Apply GZIP to compress the minified output.
  再用GZIP压缩瘦过身的。

The best part is that enabling GZIP is one of the simplest and highest payoff optimizations to implement - sadly, many people still forget to implement it. Most web servers will compress content on your behalf, and you just need to verify that the server is correctly configured to compress all the content types that would benefit from GZIP compression.
最好的部分就是启用GZIP是执行一种最简单而且最高回报的优化 - 不幸的是，很多人还是忘记去执行它。大部分Web服务器会为你的利益而压缩内容，而你只需验证服务器被正确配置来压缩所有能从GZIP压缩获益的内容类型。

What’s the best config for your server? The HTML5 Boilerplate project contains sample configuration files for all the most popular servers with detailed comments for each configuration flag and setting: find your favorite server in the list, look for the GZIP section, and confirm that your server is configured with recommended settings.
对你服务器最好的配置是什么？HTML5 Boilerplate项目(https://github.com/h5bp/server-configs)包含了大部分流行服务器的配置示例文件，而且对每种配置标记和设置都有详细注释：在列表中找到你喜欢的服务器，查找GZIP章节，确认你的服务器使用了推荐的设置。

A quick and simple way to see GZIP in action is to open Chrome Developer Tools and inspect the “Size / Content” column in the Network panel: “Size” indicates the transfer size of the asset, and “Content” the uncompressed size of the asset. For the HTML asset in above example, GZIP saved 24.8 KB during transfer!
在实际中快速简易地查看GZIP的方法就是打开Chrome开发人员工具，在Network面板检查“Size / Content”一列：“Size”指出资产的传输大小，而“Content”是未压缩的资产大小。对于上述示例中的HTML资产，GZIP在传输中节省了24.8KB。

Remember
切记

Believe it or not, there are cases where GZIP can increase the size of the asset. Typically, this happens when the asset is very small and the overhead of the GZIP dictionary is higher than the compression savings, or if the resource is already well compressed. Some servers allow you to specify a “minimum filesize threshold” to avoid this problem.
不管信不信，有时GZIP会增加资产大小。这典型地发生在资产特别小而GZIP字典大过了压缩所能节省的，或者资源已被深度压缩过。有些服务器允许你指定“最小文件大小阀值”来避免这个问题。

Finally, a word of warning: while most servers will automatically compress the assets for you when serving them to the user, some CDNs require extra care and manual effort to ensure that the GZIP asset is served. Audit your site and ensure that your assets are, in fact, being compressed!
最后，一句话提醒：虽然大部分服务器会在为用户提供服务的时候为你自动压缩资产，但一些CDN需要额外关注并动手查看确保GZIP服务。审计你的网站，确保你的资产，确实，被压缩了！

=====================================
OPTIMIZING CONTENT EFFICIENCY
优化内容效率
=====================================

Image optimization
图片优化

Images often account for most of the downloaded bytes on a web page and also often occupy a significant amount of visual space. As a result, optimizing images can often yield some of the largest byte savings and performance improvements for your website: the fewer bytes the browser has to download, the less competition there is for the client's bandwidth and the faster the browser can download and render useful content on the screen.
图片通常被认为是一个页面占最大的下载字节数并且通常占据可观的可视空间。那么，优化图片通常能对你的网站产生最大的字节减省和性能提升：浏览器要下载的字节越少，对客户端的带宽争夺也就越少，而且浏览器也能更快地下载并在屏幕上渲染有用的内容。

In this guide
本节主要内容

  ·Eliminating and replacing images
  去除和替换图片
  ·Vector vs. Raster images
  矢量和光栅图片
  ·Implications of high-resolution screens
  高分辨率屏幕的影响
  ·Optimizing vector images
  优化矢量图片
  ·Optimizing raster images
  优化光栅图片
  ·Lossless vs lossy image compression
  无损和有损图片压缩
  ·Selecting the right image format
  选择正确的图片格式
  ·Tools and parameter tuning
  工具和参考调整
  ·Delivering scaled image assets
  传送缩放过的图片资产
  ·Image optimization checklist
  图片优化检查清单

Image optimization is both an art and science: an art because there is no one definitive answer for how best to compress an individual image, and a science because there are many well developed techniques and algorithms that can significantly reduce the size of an image. Finding the optimal settings for your image requires careful analysis along many dimensions: format capabilities, content of encoded data, quality, pixel dimensions, and more.
图片优化既是艺术也是科学：说艺术是因为对于如何压缩一个单独的图片是最好的没有权威的答案，说科学因是因为有很多发展良好的技术和算法能够大大减少图片体积。为你的图片寻找最佳设置需要仔细分析很多规格：格式能力、编码数据内容、质量、像素度等等。

Eliminating and replacing images
去除和替换图片

TL;DR
简而言之

  ·Eliminate unnecessary image resources
  去除不必要的图片资源
  ·Leverage CSS3 effects where possible
  可能的话尽量使用CSS3特效
  ·Use web fonts instead of encoding text in images
  使用web字体而不是在图片里编码文本

The very first question you should ask yourself is whether an image is, in fact, required to achieve the effect you are after. Good design is simple and will also always yield the best performance. If you can eliminate an image resource, which often requires a large number of bytes relative to HTML, CSS, JavaScript and other assets on the page, then that is always the best optimization strategy. That said, a well-placed image can also communicate more information than a thousand words, so it is up to you to find that balance.
最先要问自己的问题就是，一个图片是否要用来实现那个效果。好的设计很简单而且也通常会有最佳性能。如果你能去除一个图片资源，通常它会请求与HTML、CSS、JavaScript以及页面上其他的资产有联系的大量的字节，那几乎就是最佳的优化策略。人家总说放一个合适的图片抵得过千言万语，所以这要由你来找到平衡。

Next, you should consider if there is an alternative technology that could deliver the desired results, but in a more efficient manner:
接下来，你要考虑是否有其他技术可以提供渴望的结果，而且用更有效的方式。

  ·CSS effects (gradients, shadows, etc.) and CSS animations can be used to produce resolution-independent assets that always look sharp at every resolution and zoom level, often at a fraction of the bytes required by an image file.
  CSS特效(渐变、阴影等等)以及CSS动画能用来生产与分辨率无关的资产在各种分辨率和缩放级别下看起来总是很清晰，通常占用的字节数只是图片文件的一小部分。
  ·Web fonts enable use of beautiful typefaces while preserving the ability to select, search, and resize text - a significant improvement in usability.
  Web字体能用上漂亮上的字型同时保留选择、搜索和缩放文本的能力 - 可用性方面的巨大进步。

If you ever find yourself encoding text in an image asset, stop and reconsider. Great typography is critical to good design, branding, and readability, but text-in-images delivers a poor user experience: the text is not selectable, not searchable, not zoomable, not accessible, and not friendly for high-DPI devices. The use of web fonts requires its own set of optimizations, but it addresses all of these concerns and is always a better choice for displaying text.
若曾发现自己在图片资产中编码了文本，停止并重新考虑一下。好的排版对好的设计、品牌和可读性是很关键的，但是图片里的文本传达了一个差的用户体验：文本不能被复制、不能被搜索、不能被缩放、不易访问而且对于高DPI设备不友好。使用Web字体需要它自己的一套优化办法，但是它能解决这些问题而且对显示文本是个更好的选择。

Vector vs. Raster images
矢量和光栅图片

TL;DR
简而言之

  ·Vector images are ideal for images that consist of geometric shapes
  矢量图对于由几何图形组成的图片是很理想的
  ·Vector images are zoom and resolution-independent
  矢量图可以缩放并且是分辨率无关的
  ·Raster images should be used for complex scenes with lots of irregular shapes and details
  光栅图适用于包含大量不规则形状和细节的复杂场景

Once you’ve determined that an image is, in fact, the optimal format to achieve the desired effect, the next critical choice is to select the appropriate format:
一旦你确定下来图片就是最好的能提供想要的效果的格式，下一个关键决定就是选择合适的格式：

  ·Vector graphics use lines, points, and polygons to represent an image.
  矢量图使用线条、点、多边形来描绘一个图片。
  ·Raster graphics represent an image by encoding the individual values of each pixel within a rectangular grid.
  光栅图在一个矩形格子里通过将每个独立的像素值编码来描绘一个图片

Each format has its own set of pros and cons. Vector formats are ideally suited for images that consist of simple geometric shapes (e.g. logos, text, icons, and so on), and deliver sharp results at every resolution and zoom setting, which makes them an ideal format for high-resolution screens and assets that need to be displayed at varying sizes.
每种格式都有自己的一些赞成与反对的理由。矢量格式对于由简单几何图形构成的图片(例如，logo、文本、图标等等)是很理想的，而且在每种分辨率和缩放设置下都能很清晰，这使得它们对于高分辨率屏幕和需要以多种尺寸显示的资产是一种很理想的格式。

However, vector formats fall short when the scene is complicated (e.g. a photo): the amount of SVG markup to describe all the shapes can be prohibitively high and the output may still not look “photorealistic”. When that’s the case, that’s when you should be using a raster image format such as GIF, PNG, JPEG, or one of the newer formats such as JPEG-XR and WebP.
然而，矢量格式在场景变得复杂时(例如，一张照片)就不再适用了：为描述所有形状的SVG标记总量已经高到无法接受的程度，而且输出结果依然看上去不够真实。如果是这种情况，那就是你应该使用光栅图片格式的时候，比如GIF、PNG或者一种新的格式比如JPEP-XR和WebP。

Raster images do not have the same nice properties of being resolution or zoom independent - when you scale up a raster image you’ll see jagged and blurry graphics. As a result, you may need to save multiple versions of a raster image at various resolutions to deliver the optimal experience to your users.
光栅图片在分辨率和缩放无关性方面就没这么好 - 当你放大一个光栅图你会看到锯齿和模糊的图像。那么，你可能需要为不同的分辨率保存多个版本的光栅图片来为你的用户提供最佳体验。

Implications of high-resolution screens
高分辨率屏幕的影响

TL;DR
简而言之

  ·High resolution screens have multiple device pixels per CSS pixel
  高分辨率屏幕每个CSS像素有多个设备像素
  ·High resolution images require significantly higher number of pixels and bytes
  高分辨率图片需要非常多的像素和字节
  ·Image optimization techniques are the same regardless of resolution
  图片优化技术同样不管分辨率

When we talk about image pixels, we need to distinguish between different kinds of pixels: CSS pixels and device pixels. A single CSS pixel may contain multiple device pixels - e.g. a single CSS pixel may correspond directly to a single device pixel, or may be backed by multiple device pixels. What’s the point? Well, the more device pixels there are, the finer the detail of the displayed content on the screen.
在我们讨论图片像素的时候，我们需要辨别不同的像素：CSS像素和设备像素。一个CSS像素可能包含多个设备像素 - 例如，一个CSS像素可能直接对应一个设备像素，也可能是多个设备像素。重点是什么？设备像素越多，屏幕上显示内容的细节也就越好。

High DPI (HiDPI) screens produce beautiful results, but there is one obvious tradeoff: our image assets require more detail in order to take advantage of the higher device pixel counts. The good news is, vector images are ideally suited for this task, as they can be rendered at any resolution with sharp results - we might incur a higher processing cost to render the finer detail, but the underlying asset is the same and is resolution independent.
高DPI屏幕能提供华丽的显示效果，但也有明显要权衡的：我们的图片资产需要更多细节以利用更高的设备像素数。好消息是，矢量图对于这项任务非常适合，因为它们可以被渲染成任何分辨率都很清晰 - 可能要消耗更多的运算来渲染好的细节，但标的资产是一样的而且与分辨率无关。

On the other hand, raster images pose a much larger challenge because they encode image data on a per-pixel basis. Hence, the larger the number of pixels, the larger the filesize of a raster image. As an example, let’s consider the difference between a photo asset displayed at 100x100 (CSS) pixels:
另一方面，光栅图片造成了更大的挑战，因为它们以每像素为基础给图像编码。因此，像素数越多，光栅图片的文件体积也越大。举个例子，我们考虑一个以100x100(CSS)像素显示的照片资产之间的不同：

When we double the resolution the physical screen the total number of pixels increases by a factor of four: double the number of horizontal pixels, times double the number of vertical pixels. Hence, a “2x” screen not just doubles, but quadruples the number of required pixels!
当把物理屏幕分辨率翻倍，像素总数就增长为4倍：水平方向像素翻倍，乘以翻倍的垂直方向像素。因此，一个“2x”屏幕不仅是2倍，而是所需要像素数量的4倍！

So, what does this mean in practice? High resolution screens enable us to deliver beautiful images, which can be a great product feature. However, high resolution screens also require high-resolution images: prefer vector images whenever possible as they are resolution independent and always deliver sharp results, and if a raster image is required, deliver and optimize multiple variants of each image - keep reading for further details.
那么，这在实践中意味着什么呢？高分辨率的屏幕让我们能展示华丽的图片，会成为很棒的产品功能。然而，高分辨率屏幕也需要高分辨率的图片：只要有可能最好用矢量图因为它们是分辨率无关的而且总能清晰地显示，而如果需要光栅图片，交付并优化每个图片的各个方面 - 请继续阅读更多详情。

Optimizing vector images
优化矢量图片

TL;DR
简而言之

  ·SVG is an XML-based image format
  SVG是基于XML的图片格式
  ·SVG files should be minified to reduce their size
  SVG文件应该缩小以减少它们的体积
  ·SVG files should be compressed with GZIP
  SVG文件应该用GZIP压缩

All modern browsers support Scalable Vector Graphics (SVG), which is an XML-based image format for two-dimensional graphics: we can embed the SVG markup directly on the page, or as an external resource. In turn, an SVG file can be created by most vector-based drawing software, or by hand and directly in your favorite text editor.
所有现代浏览器都支持Scalable Vector Graphics (SVG)，这是一种为二维图形准备的基于XML的图像格式：我们能直接在页面里嵌入SVG标记，或者作为一个外部资源。反之，一个SVG文件可由大多数基于矢量的绘图软件生成，或者在你喜欢的文本编辑器里直接手写。

<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 17.1.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.2" baseProfile="tiny" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 612 792" xml:space="preserve">
<g id="XMLID_1_">
  <g>
    <circle fill="red" stroke="black" stroke-width="2" stroke-miterlimit="10" cx="50" cy="50" r="40"/>
  </g>
</g>
</svg>

The above example renders a simple circle shape with a black outline and red background and was exported from Adobe Illustrator. As you can tell, it contains a lot of metadata, such as layer information, comments, and XML namespaces that are often unnecessary to render the asset in the browser. As a result, it is always a good idea to minify your SVG files by running through a tool like svgo.
上面的示例渲染了一个简单的黑色外框红色背景的圆形，是由Adobe Illustrator导出的。象你能讲出来的那样，它包含了大量的元数据，例如层信息、注释以及XML命名空间，通常在浏览器里渲染资产时是不必要的。那么，通过svgo这样的工具来缩小你的SVG文件总是一个好主意(https://github.com/svg/svgo)。

Case in point, svgo reduces the size of the above SVG file generated by Illustrator by 58%, taking it from 470 to 199 bytes. Further, because SVG is an XML-based format, we can also apply GZIP compression to reduce its transfer size - make sure your server is configured to compress SVG assets!
实际证明，svgo将上面由Illustrator生成的SVG文件减少了58%，把它从470减少到199字节。而且，因为SVG是一种基于XML的格式，我们也可以应用GZIP压缩来减少它的传输大小 - 请确认你的服务器被配置来压缩SVG资产！

Optimizing raster images
优化光栅图片

TL;DR
简而言之

  ·A raster image is a grid of pixels
  光栅图片是一组像素栅格
  ·Each pixel encodes color and transparency information
  每个像素都要把颜色和透明度信息进行编码
  ·Image compressors use a variety of techniques to reduce the number of required bits per pixel to reduce file size of the image
  图片压缩器使用多种技术来减少每个像素需要的数据量从而达到减小图片文件大小的目标

A raster image is simply a 2-dimensional grid of individual “pixels” - e.g. a 100x100 pixel image is a sequence of 10,000 pixels. In turn, each pixel stores the “RGBA” values: (R) red channel, (G) green channel, (B) blue channel, and (A) alpha (transparency) channel.
光栅图片是一种简单的二维的由独立像素组成的栅格 - 例如，一个100x100像素的图片是10,000像素的序列。挨过来说，每个像素都保存了“RGBA”值：(R)红色通道(G)绿色通道(B)蓝色通道(A)透明通道。

Internally, the browser allocates 256 values (shades) for each channel, which translates to 8 bits per channel (28 = 256), and 4 bytes per pixel (4 channels x 8 bits = 32 bits = 4 bytes). As a result, if we know the dimensions of the grid we can easily calculate the filesize:
在内部处理中，浏览器为每个通道分配256个值(渐变的)，转换成每个通道8位(28=256)，每个像素4个字节(4通道x8位=32位=4字节)。如果我们知道栅格的定义很容易就能计算出文件大小：

  ·100 x 100px image is composed of 10,000 pixels
  ·10,000 pixels x 4 bytes = 40,000 bytes
  ·40,000 bytes / 1024 = 39 KB

Note
注意

  As an aside, regardless of the image format used to transfer the data from the server to the client, when the image is decoded by the browser, each pixel always occupies 4 bytes of memory. This can be an important constraint for large images and devices which do not have a lot of available memory - e.g. low-end mobile devices.
顺便说一句，不管从服务器端向客户端传输的图片格式是什么，当图片在浏览器被解码的时候，每个像素总是占据4字节的内存。对于没有大量可用内存的设备和大图片，这会是重要的限制因素 - 例如低端移动设备。























