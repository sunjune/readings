Optimizing Content Efficiency
优化内容效率

Our web applications continue to grow in their scope, ambition, and functionality - that's a good thing. However, the relentless march towards a richer web is driving another trend: the amount of data downloaded by each application continues to increase at a steady pace. To deliver great performance we need to optimize delivery of each and every byte of data!
我们的web应用持续增长着它们的范围、雄心和功能 - 这是件好事。然而，这种无情的向富web迈进带来了另一个趋势：每个应用要下载的数据总量稳定持续增长。要提供更好的性能我们需要对每个字节的数据进行优化。

What does a modern web application look like? HTTP Archive can help us answer this question. The project tracks how the web is built by periodically crawling the most popular sites (300,000+ from the Alexa Top 1M list) and recording and aggregating analytics on the number resources, content types, and other metadata for each individual destination.
一个现代浏览器看上去是什么样的？HTTP Archive(http://httparchive.org/)能帮我们回答这个疑问。这个项目通过周期性地爬虫收集最流行的网站(Alexa前1百万名单中的30万以上)并对每个单独的目标记录和汇总分析资源数量、内容类型以及其他的元数据。

The above data captures the trend in growth of number of downloaded bytes for popular destinations on the web between January 2013 and January 2014. Of course, not every site grows at the same rate or requires the same amount of data, hence the reason why we are highlighting the different quantiles within the distribution: 50th (median), 75th, and 90th.
上面的数据获取的是2013年1月到2014年1月之间流行网站被下载的总字节数的增长趋势。当然了，不是每个网站都以这种速率增长或请求同样的数据量，这就是为什么我们高亮显示不同的百分比：第50(中值)、第75和第90。

A median site at the beginning of 2014 is composed of 75 requests that add up to 1054 KB of total transferred bytes, and the total number of bytes (and requests) has grown at a steady pace throughout the previous year. This by itself should not be all that surprising, but it does carry important performance implications: yes, internet speeds are getting faster, but they are getting faster at different rates in different countries, and many users are still subject to data caps and expensive metered plans - especially on mobile.
2014年初的中值站点有75次合计达到1054KB的传输字节，而且过去一年字节总数(以及请求数)稳步增长。就它本身来说这没什么好吃惊的，但它带着重要的性能影响：是的，网速越来越快，但在不同的国家变快的速率不同，而且很多用户仍然受制于数据上限和昂贵的流量计划 - 特别是在移动端。

Unlike their desktop counterparts, web applications do not require a separate installation process: enter the URL and we are up and running – that’s a key feature of the web. However, to make this happen we often have to fetch dozens, and sometime hundreds, of various resources, all of which can add up to megabytes of data and must come together in hundreds of milliseconds to facilitate the instant web experience we are aiming for.
与桌面应用不同的是，web应用不用单独安装：进入URL我们就启动运行了 - 这是网站的主要特色。然而，要实现这个我们通常要取得数十甚至数百的各种资源，合计达到数M字节的数据，而且必须在几百毫秒内把它们汇集到一起来让我们目标中的迅捷网站体验成为现实。

Achieving an instant web experience in light of these requirements is no small feat, which is why optimizing content efficiency is critical: eliminating unnecessary downloads, optimizing transfer encoding of each resource through various compression techniques, and leveraging caching whenever possible to eliminate redundant downloads.
在这么多的请求下要达到迅捷网站体验可是个不小的壮举，这就是为什么优化内容效率是很关键的：去掉不必须的下载、通过多种压缩技术对每种资源进行优化传输编码、只要有可能就借助缓存来减少多余的下载。

=====================================
Eliminating unnecessary downloads
去掉不必要的下载
=====================================

The fastest and best optimized resource is a resource not sent. Have you audited your resources recently? You should, and you should do so periodically to ensure that each resource is helping deliver a better user experience.
最快最优化的资源就是没有发送出去的资源。你最近审计过你的资源吗？你应该，而且应该定期确认每个资源都有助于提供更好的用户体验。

TL;DR
简而言之

  ·Inventory all own and third party assets on your pages
  清点你页面上所有自主和第三方的资源
  ·Measure the performance of each asset: its value and its technical performance
  测量每个资源的性能：它的重要性和它的技术性能
  ·Determine if the resources are providing sufficient value
  确定这些资源是否提供足够的价值

In this guide
本节主要内容

The fastest and best optimized resource is a resource not sent. Of course, this may seem like an obvious statement, but in practice it is all too often overlooked: as a performance engineer, it is your job to always maintain a critical eye for any opportunity to eliminate unnecessary resources from your application. It’s a good practice to question, and periodically revisit, the implicit and explicit assumptions with your team. A few examples:
最快速最佳的资源就是没有发出去的资源。当然，这可能看起来像是个很明显的说法，但在实际中它常常被忽略：作为一个高性能工程师，总是保持挑剔的眼光抓住任何机会从你的应用中剔除那些不必要的资源就是你的工作。好的练习包括提问、周期性地重复访问、与你的团队暗示或明确地假设。举例如下：
  
  ·We’ve always included resource X on our pages, but does the cost of downloading and displaying it offset the value it delivers to the user? Can we measure and prove its value?
  我们总是包含着一个资源X在我们的页面上，但是下载并显示它的开销能补偿它带给用户的价值吗？我们能测定并证明它的价值吗？
  ·Does the resource — especially if it is a third-party resource — deliver consistent performance? Is this resource in the critical path, or need to be? If the resource is in the critical path, could it be a single point of failure for our site - i.e. if the resource is unavailable, will it affect performance and the user experience of our pages?
  这个资源 — 特别是如果是个第三方资源 — 能保持稳定的性能吗？这个资源在关键路径里吗，或者说需要在吗？如果资源是关键路径里的，它会成为我们网站失败的单点吗？ - 换句话说，如果资源不可用，它会影响我们页面的性能和用户体验吗？
  ·Does this resource need or have an SLA? Does this resource follow performance best practices: compression, caching, and so on?
  资源需要或已经有SLA(服务等级协议)了吗？资源遵从性能最佳实践了吗：压缩、缓存等等？
  
All too frequently our pages contain resources which are unnecessary, or worse, hinder page performance without delivering much value to the visitor or the site they are hosted on. This applies equally to first-party and third-party resources and widgets:
我们的页面包含太多不必要的资源，或者更糟的，阻碍了页面性能且没有提供更多价值给访问者或它们所在的网站。这同样适用于第一方和第三方资源和小部件：

  ·Site A has decided to display a photo carousel on its homepage to allow the visitor to preview multiple photos with a quick click — all the photos are loaded when the page is loaded, and photos are advanced by the user.
  站点A决定在首页显示一个照片轮播，允许用户通过快速点击来预览多个照片 — 当页面加载的时候所有图片都被加载了，而且照片被用户提高。
    ·Question: have you measured how many users view multiple photos in the carousel? You could be incurring high overhead by downloading unnecessary resources which are never viewed by most visitors.
    问题：你测量过有多少用户在轮播里看多张照片吗？你会招致过多非必要资源的下载流量，而大部分访问者从来都没看过。
  ·Site B has decided to install a third-party widget to display related content, improve social engagement, or provide some other service.
  站点B决定安装一个第三方小部件来显示相关内容，提升社交参与度，或者提供一些其他服务。
    ·Question: have you tracked how many visitors use the widget or click-through on the content provided by the widget? Is the engagement generated by this widget enough to justify its overhead?
    问题：你跟踪过有多少访问者使用了小部件或从它提供的内容上点击了吗？部件所产生的参与度与它的消耗对等吗？

As you can see, while eliminating unnecessary downloads seems like a trivial statement, in practice it is anything but, as it often requires a lot careful thinking and measurement to make the call. In fact, for best results you should periodically inventory and revisit these questions for each and every asset on your pages.
就像你看到的，虽然去除不必要的下载看上去是琐碎的说法，但实际上它是任何事，因为它经常需要大量的认真思考和测量来最终实施。事实上，为了最佳结果，你应该定期盘点页面上的东西并重新审视这些问题。

============================================================
Optimizing encoding and transfer size of text-based assets
优化基于文本的编码和传输大小
============================================================

Our web applications continue to grow in their scope, ambition, and functionality - that's a good thing. However, the relentless march towards a richer web is driving another trend: the amount of data downloaded by each application continues to increase at a steady pace. To deliver great performance we need to optimize delivery of each and every byte of data!
我们的web应用持续增长着它们的范围、雄心和功能 - 这是件好事。然而，这种无情的向富web迈进带来了另一个趋势：每个应用要下载的数据总量稳定持续增长。要提供更好的性能我们需要对每个字节的数据进行优化。

In this guide
本节主要内容

  ·Data compression 101
  数据压缩101
  ·Minification: preprocessing & context-specific optimizations
  最小化：预压缩和上下文指定优化
  ·Text compression with GZIP
  用GZIP压缩文本

Data compression 101
数据压缩101

Once we’ve eliminated any unnecessary resources, the next step is to minimize the total size of the remaining resources the browser has to download - i.e. compress them. Depending on the resource type - text, images, fonts, and so on - we have a number of different techniques at our disposal: generic tools that can be enabled on the server, pre-processing optimizations for specific content-types, and resource specific optimizations that require input from the developer.
Delivering the best performance requires the combination of all of these techniques.
一旦我们去除了不必要的资源，下一步就是最小化浏览器要下载的其余资源总大小了 - 也就是，压缩它们。根据资源类型 - 文本、图片、字体等等 - 我们有大量不同的技术供支配：一般的可以在服务器端启用的工具、对指定内容类型的预压缩优化以及需要由开发者输入的资源特定优化。为达到最佳性能要对所有这些技术综合利用。

TL;DR
简而言之

  ·Compression is the process of encoding information using fewer bits
  压缩就是用更少的数据把信息编码的过程
  ·Eliminating unnecessary data always yields the best results
  去掉不必要的数据总是能达成最好的结果
  ·There are many different compression techniques and algorithms
  有很多种不同的压缩技术和算法
  ·You will need a variety of techniques to achieve the best compression
  你将需要不同的技术来实现最佳压缩率

The process of reducing the size of data is known as “data compression,” and it is a deep field of study on its own: many people have spent their entire careers working on algorithms, techniques, and optimizations to improve compression ratios, speed, and memory requirements of various compressors. Needless to say, a full discussion on this topic is out of our scope, but it is still important to understand, at a high level, how compression works and the techniques we have at our disposal to reduce the size of various assets required by our pages.
减少数据大小的处理过程被称为“数据压缩”，而且是一个很深的自行研究领域：很多人终其全部的职业生涯致力于研究各种压缩算法、技术以及优化并提升压缩比、速度和内存占用。就不展开说了，关于这个话题的讨论超出了我们的范围，但是对压缩如何进行以及我们减少页面所需的各项内容的大小所用到的技术的有高一点的理解是很重要的。

To illustrate the core principles of these techniques in action, let’s consider how we can go about optimizing a simple text message format that we’ll invent just for this example:
为了用实例说明这些技术的核心原理，让我们想一下如何优化一段简单的文本消息格式，只是为这个示例而发明的：

# Below is a secret message, which consists of a set of headers in
# key-value format followed by a newline and the encrypted message.
下面是一段秘密消息，由key-value格式的报头跟随着新起的一行以及加密的消息组成。
format: secret-cipher
date: 04/04/14
AAAZZBBBBEEEMMM EEETTTAAA

  01 Messages may contain arbitrary annotations, which are indicated by the “#” prefix. Annotations do not affect the meaning or any other behavior of the message.
  消息可能包含一些以“#”前缀标识的注释。注释不会影响消息的含意或其他行为。
  02 Messages may contain “headers” which are key-value pairs (separated by “:”) and have to appear at the beginning at the message.
  消息可能会包含“报头”，由key-value对(以“:”分隔)而且一定要出现在消息最开始的地方。
  03 Messages carry text payloads.
  消息携带文本内容。

What could we do reduce the size of the above message, which is currently 200 characters long?
我们能做点什么来减少上面有200个字符的消息体积呢？

  01 Well, the comment is interesting, but we know that it doesn’t actually affect the meaning of the message, so we eliminate it when we’re transmitting the message.
  注释挺有意思的，但是我们知道实际上它并不影响消息的含意，那么我们在传送消息的时候就把它去掉了。
  02 There are probably some clever techniques we could use to encode headers in an efficient manner – e.g. we don’t know if all messages always have “format” and “date”, but if they did, we could convert those to short integer IDs and just send those! That said, we’re not sure if that’s the case, so we’ll leave it alone for now.
  可能有一些聪明的技术手段让我们能以一种高效的方式来给报头编码 - 例如，我们不知道是否所有的消息总是带有“format”和“date”，但是如果有，我们就能把它些转换成短的整数ID而且只要发送它们就行了！就是说，我们不确定是否是这样，所以就先把它放在一边吧。
  03 The payload is text only, and while we don’t know what the contents of it really are (apparently, it’s using a “secret-message”), just looking at the text seems to show that there is a lot of redundancy in it. Perhaps, instead of sending repeated letters, we can just count the number of repeated letters and encode them more efficiently?
  内容只是文本，而且我们不知道内容到底是什么(很明显，它使用的是“密文”)，只是看字面好像有很多重复。或许，不用发送重复的字符，我们只要数一下重复字符的个数并且编码会更有效？

E.g. “AAA” becomes “3A” - or, sequence of three A’s.
例如：“AAA”改成“3A” - 或者顺序的三个A。

Combining our techniques, we arrive at the following result:
联合我们的技术，我们得到如下结果：

format: secret-cipher
date: 04/04/14
3A2Z4B3E3M 3E3T3A

The new message is 56 characters long, which means we managed to compress our original message by an impressive 72% - not bad, all things considered, and we’re only getting started!
新的消息长度是56个字符，这意味着我们设法将原始消息压缩了72% - 不错，所有事情都考虑到了，而我们才刚刚开始！

Of course, you may be wondering, this is all great, but how does this help us optimize our web pages? Surely we’re not going to try to invent our compression algorithms, are we? The answer is no, we won’t, but as you will see, we will use the exact same techniques and way of thinking when optimizing various resources on our pages: preprocessing, context-specific optimizations, and different algorithms for different content.
当然，你可能会吃惊这太棒了，但是这怎么帮助我们优化我们的页面呢？我们确实没有想发明压缩算法，是吗？答案是否，我们不会那样做，但是你将会看到，我们在优化页面上的各种资源时将使用同样的技术和思路：预处理、上下文特征优化以及为不同的内容使用不同的算法。

Minification: preprocessing & context-specific optimizations
缩小倍数：预处理和上下文特征优化

TL;DR
简而言之

  ·Content-specific optimizations can significantly reduce the size of delivered resources.
  内容特征优化可以显著地减少交付资源的大小。
  ·Content-specific optimizations are best applied as part of your build/release cycle.
  内容特征优化最好应用于你的生产/发布循环。

The best way to compress redundant or unnecessary data is to eliminate it altogether. Of course, we can’t just delete arbitrary data, but in some contexts where we may have content-specific knowledge of the data format and its properties, it is often possible to significantly reduce the size of the payload without affecting its actual meaning.
压缩多余或不必要的数据最好的办法是完全去掉它们。当然了，我们不能仅仅随意删除数据，但是在一些环境中我们可能对数据格式与其属性的内容特征有所了解，通常可能会大大减少负载而不会影响其真实含意。

    <html>
      <head>
      <style>
         /* awesome-container is only used on the landing page */
         .awesome-container { font-size: 120% }
         .awesome-container { width: 50% }
      </style>
     </head>
    
     <body>
       <!-- awesome container content: START -->
        <div>…</div>
       <!-- awesome container content: END -->
       <script>
         awesomeAnalytics(); // beacon conversion metrics
       </script>
     </body>
    </html>

Consider the simple HTML page above and the three different content types that it contains: HTML markup, CSS styles, and JavaScript. Each of these content types has different rules for what constitutes valid HTML markup, CSS rules, or JavaScript content, different rules for indicating comments, and so on. How could we reduce the size of this page?
看一下上面这个简单的HTML页面，里面有三种不同的内容类型：HTML标记、CSS样式以及JavaScript。这每种内容类型都有不同的规则构成了有效的HTML标记、CSS规则或JavaScript内容，标识注释的不同规则，等等。

  ·Code comments are a developer’s best friend, but the browser does not need to see them! Simply stripping the CSS (/* … */), HTML (<!-- … -->), and JavaScript (// …) comments can significantly reduce the total size of the page.
  代码注释是开发人员最好的朋友，但是浏览器不用看它们！简单地剔除CSS(/*…*/)，HTML(<!-- … -->)以及JavaScript(// …)的注释能有效减少页面总大小。
  ·A “smart” CSS compressor could notice that we’re using an inefficient way of defining rules for ‘.awesome-container’ and collapse the two declarations into one without affecting any other styles, saving yet more bytes.
  聪明的CSS压缩器能注意到我们在‘.awesome-container’使用了效率差的定义规则的方式而将两个声明合并到一个里面而不会对样式有任何影响，同时也节省了更多字节。
  ·Whitespace (spaces and tabs) is a developer convenience in HTML, CSS, and JavaScript. An additional compressor could strip out all the tabs and spaces.
  空白(space和tab)是开发者在HTML、CSS和JavaScript中很有用的。有压缩工具可以剔除所有的tab和空白。

   <html><head><style>.awesome-container{font-size:120%;width: 50%}
    </style></head><body><div>…</div><script>awesomeAnalytics();
    </script></body></html>

After applying the above steps our page goes from 406 to 150 characters - 63% compression savings! Granted, it’s not very readable, but it also doesn’t have to be: we can keep the original page as our “development version” and then apply the steps above whenever we are ready to release the page on our website.
经过上述步骤我们的页面从406减少到150字符 - 压缩了63%！不过，它变得非常不易读，但也不是一定要这样：我们可以保存原始页面作为我们的“开发版”然后当准备发布页面到网站的时候再应用上述步骤。

Taking a step back, the above example illustrates an important point: a general purpose compressor - say one designed to compress arbitrary text - could probably also do a pretty good job of compressing the page above, but it would never know to strip the comments, collapse the CSS rules, or dozens of other content-specific optimizations. This is why preprocessing / minification / context-aware optimization can be such a powerful tool.
回头再看，上述示例说明了重要的一点：通常用途的压缩器 - 是说设计用于压缩随便哪种文本的 - 可能也能很好地用于压缩上述页面，但它永远也不知道去除注释、合并CSS规则或更多其他的内容特征优化。这就是为什么预处理/缩小率/上下文相关优化是如此强大的工具。

Remember
切记

Case in point, the uncompressed development version of the JQuery library is now approaching ~300KB. The same library, but minified (removed comments, etc.) is about 3x smaller: ~100KB.
注意一点，未压缩的JQuery库的开发版现在将近300KB。经过缩小同样的库(去除了注释等)大约小了3倍：100KB左右。

Similarly, above techniques can be extended beyond just text-based assets. Images, video, and other content types all contain their own forms of metadata and various payloads. For example, whenever you take a picture with a camera, the photo also typically embeds a lot of extra information: camera settings, location, and so on. Depending on your application, this data may be critical (e.g. a photo sharing site), or completely useless and you should consider whether it is worth removing. In practice, this metadata can add up to tens of kilobytes for every image!
同样的，上述技术也可扩展到文本内容以外。图片、视频以及其他内容类型都包含它们自己的元数据形式以及各种负载。比如，在你用相机拍了一张照片，照片也基本上会嵌入大量的附加信息：相机设定、地点等等。对你的应用来说，这些数据可能是关键的(例如照片分享网站)，或者根本没用而且你要考虑是否值得删除。实际上，每张图片中这些元数据总计能达到数十KB！

In short, as a first step in optimizing the efficiency of your assets, build an inventory of the different content types and consider what kinds of content-specific optimizations you can apply to reduce their size - doing so can yield significant savings! Then, once you’ve figured out what they are, automate these optimizations by adding them to your build and release processes - that’s the only way you can guarantee that the optimizations will stay in place.
总之，作为优化你的资产效能的第一步，对不同内容类型列一个清单并且考虑你能用哪种内容特征优化来减少它们的大小 - 做这些可以有显著的节省。接下来，一旦你已经找出它们，把这些优化做成自动化的并加入到你开发和发布流程中 - 这是保证优化能保持下来的惟一方法。

Text compression with GZIP
用GZIP压缩文本

TL;DR
简而言之

  ·GZIP performs best on text-based assets: CSS, JavaScript, HTML
  GZIP在文本资产上执行得最好：CSS、JavaScript和HTML。
  ·All modern browsers support GZIP compression and will automatically request it
  所有现代浏览器都支持GZIP压缩而且会自动请求它。
  ·Your server needs to configured to enable GZIP compression
  你的服务器需要配置以启用GZIP压缩。
  ·Some CDNs require special care to ensure that GZIP is enabled
  一些CDN要特别注意确保GZIP是启用的。

GZIP is a generic compressor that can be applied to any stream of bytes: under the hood it remembers some of the previously seen content and attempts to find and replace duplicate data fragments in an efficient way - for the curious, great low-level explanation of GZIP. However, in practice, GZIP performs best on text-based content, often achieving compression rates of as high as 70-90% for larger files, whereas running GZIP on assets that are already compressed via alternative algorithms (e.g. most image formats) yields little to no improvement.
GZIP是一种通用压缩器可以用于任何字节流：它会记住前面看过的内容并以高效的方式尝试查找重复数据碎片 - 如果有兴趣，请参阅(https://www.youtube.com/watch?v=whGwm0Lky2s&feature=youtu.be&t=14m11s)。然而，实际上GZIP在文本内容上运行得最好，对于大文件通常压缩比高达70-90%，但是对于已经用其他算法压缩过的内容资产(例如大部分图片格式)运行GZIP提高就很小甚至没有。

All modern browsers support and automatically negotiate GZIP compression for all HTTP requests: our job is to ensure that the server is properly configured to serve the compressed resource when requested by the client.
所有现代浏览器都支持并自动对所有的HTTP请求协商GZIP压缩：我们的工作就是确保服务器经过正确配置，被客户端请求的时候能提供压缩过的资源。

The above table illustrates the savings provided by GZIP compression for a few of the most popular JavaScript libraries and CSS frameworks. The savings range from 60 to 88%, and note that the combination of minified files (identified by “.min” in their filenames), plus GZIP, offers an even larger win.
上表说明了GZIP对一些最流行的JavaScript库和CSS框架压缩后能的缩减量。节省范围从60到88%，注意结合了缩小的文件(文件名中以“.min”标识的)，经过GZIP，甚至能有更大的节省。

  ·Apply content-specific optimizations first: CSS, JS, and HTML minifiers.
  首先使用内容特征优化：CSS、JS以及HTML瘦身器。
  ·Apply GZIP to compress the minified output.
  再用GZIP压缩瘦过身的。

The best part is that enabling GZIP is one of the simplest and highest payoff optimizations to implement - sadly, many people still forget to implement it. Most web servers will compress content on your behalf, and you just need to verify that the server is correctly configured to compress all the content types that would benefit from GZIP compression.
最好的部分就是启用GZIP是执行一种最简单而且最高回报的优化 - 不幸的是，很多人还是忘记去执行它。大部分Web服务器会为你的利益而压缩内容，而你只需验证服务器被正确配置来压缩所有能从GZIP压缩获益的内容类型。

What’s the best config for your server? The HTML5 Boilerplate project contains sample configuration files for all the most popular servers with detailed comments for each configuration flag and setting: find your favorite server in the list, look for the GZIP section, and confirm that your server is configured with recommended settings.
对你服务器最好的配置是什么？HTML5 Boilerplate项目(https://github.com/h5bp/server-configs)包含了大部分流行服务器的配置示例文件，而且对每种配置标记和设置都有详细注释：在列表中找到你喜欢的服务器，查找GZIP章节，确认你的服务器使用了推荐的设置。

A quick and simple way to see GZIP in action is to open Chrome Developer Tools and inspect the “Size / Content” column in the Network panel: “Size” indicates the transfer size of the asset, and “Content” the uncompressed size of the asset. For the HTML asset in above example, GZIP saved 24.8 KB during transfer!
在实际中快速简易地查看GZIP的方法就是打开Chrome开发人员工具，在Network面板检查“Size / Content”一列：“Size”指出资产的传输大小，而“Content”是未压缩的资产大小。对于上述示例中的HTML资产，GZIP在传输中节省了24.8KB。

Remember
切记

Believe it or not, there are cases where GZIP can increase the size of the asset. Typically, this happens when the asset is very small and the overhead of the GZIP dictionary is higher than the compression savings, or if the resource is already well compressed. Some servers allow you to specify a “minimum filesize threshold” to avoid this problem.
不管信不信，有时GZIP会增加资产大小。这典型地发生在资产特别小而GZIP字典大过了压缩所能节省的，或者资源已被深度压缩过。有些服务器允许你指定“最小文件大小阀值”来避免这个问题。

Finally, a word of warning: while most servers will automatically compress the assets for you when serving them to the user, some CDNs require extra care and manual effort to ensure that the GZIP asset is served. Audit your site and ensure that your assets are, in fact, being compressed!
最后，一句话提醒：虽然大部分服务器会在为用户提供服务的时候为你自动压缩资产，但一些CDN需要额外关注并动手查看确保GZIP服务。审计你的网站，确保你的资产，确实，被压缩了！

=====================================
OPTIMIZING CONTENT EFFICIENCY
优化内容效率
=====================================

Image optimization
图片优化

Images often account for most of the downloaded bytes on a web page and also often occupy a significant amount of visual space. As a result, optimizing images can often yield some of the largest byte savings and performance improvements for your website: the fewer bytes the browser has to download, the less competition there is for the client's bandwidth and the faster the browser can download and render useful content on the screen.
图片通常被认为是一个页面占最大的下载字节数并且通常占据可观的可视空间。那么，优化图片通常能对你的网站产生最大的字节减省和性能提升：浏览器要下载的字节越少，对客户端的带宽争夺也就越少，而且浏览器也能更快地下载并在屏幕上渲染有用的内容。

In this guide
本节主要内容

  ·Eliminating and replacing images
  去除和替换图片
  ·Vector vs. Raster images
  矢量和光栅图片
  ·Implications of high-resolution screens
  高分辨率屏幕的影响
  ·Optimizing vector images
  优化矢量图片
  ·Optimizing raster images
  优化光栅图片
  ·Lossless vs lossy image compression
  无损和有损图片压缩
  ·Selecting the right image format
  选择正确的图片格式
  ·Tools and parameter tuning
  工具和参考调整
  ·Delivering scaled image assets
  传送缩放过的图片资产
  ·Image optimization checklist
  图片优化检查清单

Image optimization is both an art and science: an art because there is no one definitive answer for how best to compress an individual image, and a science because there are many well developed techniques and algorithms that can significantly reduce the size of an image. Finding the optimal settings for your image requires careful analysis along many dimensions: format capabilities, content of encoded data, quality, pixel dimensions, and more.
图片优化既是艺术也是科学：说艺术是因为对于如何压缩一个单独的图片是最好的没有权威的答案，说科学因是因为有很多发展良好的技术和算法能够大大减少图片体积。为你的图片寻找最佳设置需要仔细分析很多规格：格式能力、编码数据内容、质量、像素度等等。

Eliminating and replacing images
去除和替换图片

TL;DR
简而言之

  ·Eliminate unnecessary image resources
  去除不必要的图片资源
  ·Leverage CSS3 effects where possible
  可能的话尽量使用CSS3特效
  ·Use web fonts instead of encoding text in images
  使用web字体而不是在图片里编码文本

The very first question you should ask yourself is whether an image is, in fact, required to achieve the effect you are after. Good design is simple and will also always yield the best performance. If you can eliminate an image resource, which often requires a large number of bytes relative to HTML, CSS, JavaScript and other assets on the page, then that is always the best optimization strategy. That said, a well-placed image can also communicate more information than a thousand words, so it is up to you to find that balance.
最先要问自己的问题就是，一个图片是否要用来实现那个效果。好的设计很简单而且也通常会有最佳性能。如果你能去除一个图片资源，通常它会请求与HTML、CSS、JavaScript以及页面上其他的资产有联系的大量的字节，那几乎就是最佳的优化策略。人家总说放一个合适的图片抵得过千言万语，所以这要由你来找到平衡。

Next, you should consider if there is an alternative technology that could deliver the desired results, but in a more efficient manner:
接下来，你要考虑是否有其他技术可以提供渴望的结果，而且用更有效的方式。

  ·CSS effects (gradients, shadows, etc.) and CSS animations can be used to produce resolution-independent assets that always look sharp at every resolution and zoom level, often at a fraction of the bytes required by an image file.
  CSS特效(渐变、阴影等等)以及CSS动画能用来生产与分辨率无关的资产在各种分辨率和缩放级别下看起来总是很清晰，通常占用的字节数只是图片文件的一小部分。
  ·Web fonts enable use of beautiful typefaces while preserving the ability to select, search, and resize text - a significant improvement in usability.
  Web字体能用上漂亮上的字型同时保留选择、搜索和缩放文本的能力 - 可用性方面的巨大进步。

If you ever find yourself encoding text in an image asset, stop and reconsider. Great typography is critical to good design, branding, and readability, but text-in-images delivers a poor user experience: the text is not selectable, not searchable, not zoomable, not accessible, and not friendly for high-DPI devices. The use of web fonts requires its own set of optimizations, but it addresses all of these concerns and is always a better choice for displaying text.
若曾发现自己在图片资产中编码了文本，停止并重新考虑一下。好的排版对好的设计、品牌和可读性是很关键的，但是图片里的文本传达了一个差的用户体验：文本不能被复制、不能被搜索、不能被缩放、不易访问而且对于高DPI设备不友好。使用Web字体需要它自己的一套优化办法，但是它能解决这些问题而且对显示文本是个更好的选择。

Vector vs. Raster images
矢量和光栅图片

TL;DR
简而言之

  ·Vector images are ideal for images that consist of geometric shapes
  矢量图对于由几何图形组成的图片是很理想的
  ·Vector images are zoom and resolution-independent
  矢量图可以缩放并且是分辨率无关的
  ·Raster images should be used for complex scenes with lots of irregular shapes and details
  光栅图适用于包含大量不规则形状和细节的复杂场景

Once you’ve determined that an image is, in fact, the optimal format to achieve the desired effect, the next critical choice is to select the appropriate format:
一旦你确定下来图片就是最好的能提供想要的效果的格式，下一个关键决定就是选择合适的格式：

  ·Vector graphics use lines, points, and polygons to represent an image.
  矢量图使用线条、点、多边形来描绘一个图片。
  ·Raster graphics represent an image by encoding the individual values of each pixel within a rectangular grid.
  光栅图在一个矩形格子里通过将每个独立的像素值编码来描绘一个图片

Each format has its own set of pros and cons. Vector formats are ideally suited for images that consist of simple geometric shapes (e.g. logos, text, icons, and so on), and deliver sharp results at every resolution and zoom setting, which makes them an ideal format for high-resolution screens and assets that need to be displayed at varying sizes.
每种格式都有自己的一些赞成与反对的理由。矢量格式对于由简单几何图形构成的图片(例如，logo、文本、图标等等)是很理想的，而且在每种分辨率和缩放设置下都能很清晰，这使得它们对于高分辨率屏幕和需要以多种尺寸显示的资产是一种很理想的格式。

However, vector formats fall short when the scene is complicated (e.g. a photo): the amount of SVG markup to describe all the shapes can be prohibitively high and the output may still not look “photorealistic”. When that’s the case, that’s when you should be using a raster image format such as GIF, PNG, JPEG, or one of the newer formats such as JPEG-XR and WebP.
然而，矢量格式在场景变得复杂时(例如，一张照片)就不再适用了：为描述所有形状的SVG标记总量已经高到无法接受的程度，而且输出结果依然看上去不够真实。如果是这种情况，那就是你应该使用光栅图片格式的时候，比如GIF、PNG或者一种新的格式比如JPEP-XR和WebP。

Raster images do not have the same nice properties of being resolution or zoom independent - when you scale up a raster image you’ll see jagged and blurry graphics. As a result, you may need to save multiple versions of a raster image at various resolutions to deliver the optimal experience to your users.
光栅图片在分辨率和缩放无关性方面就没这么好 - 当你放大一个光栅图你会看到锯齿和模糊的图像。那么，你可能需要为不同的分辨率保存多个版本的光栅图片来为你的用户提供最佳体验。

Implications of high-resolution screens
高分辨率屏幕的影响

TL;DR
简而言之

  ·High resolution screens have multiple device pixels per CSS pixel
  高分辨率屏幕每个CSS像素有多个设备像素
  ·High resolution images require significantly higher number of pixels and bytes
  高分辨率图片需要非常多的像素和字节
  ·Image optimization techniques are the same regardless of resolution
  图片优化技术同样不管分辨率

When we talk about image pixels, we need to distinguish between different kinds of pixels: CSS pixels and device pixels. A single CSS pixel may contain multiple device pixels - e.g. a single CSS pixel may correspond directly to a single device pixel, or may be backed by multiple device pixels. What’s the point? Well, the more device pixels there are, the finer the detail of the displayed content on the screen.
在我们讨论图片像素的时候，我们需要辨别不同的像素：CSS像素和设备像素。一个CSS像素可能包含多个设备像素 - 例如，一个CSS像素可能直接对应一个设备像素，也可能是多个设备像素。重点是什么？设备像素越多，屏幕上显示内容的细节也就越好。

High DPI (HiDPI) screens produce beautiful results, but there is one obvious tradeoff: our image assets require more detail in order to take advantage of the higher device pixel counts. The good news is, vector images are ideally suited for this task, as they can be rendered at any resolution with sharp results - we might incur a higher processing cost to render the finer detail, but the underlying asset is the same and is resolution independent.
高DPI屏幕能提供华丽的显示效果，但也有明显要权衡的：我们的图片资产需要更多细节以利用更高的设备像素数。好消息是，矢量图对于这项任务非常适合，因为它们可以被渲染成任何分辨率都很清晰 - 可能要消耗更多的运算来渲染好的细节，但标的资产是一样的而且与分辨率无关。

On the other hand, raster images pose a much larger challenge because they encode image data on a per-pixel basis. Hence, the larger the number of pixels, the larger the filesize of a raster image. As an example, let’s consider the difference between a photo asset displayed at 100x100 (CSS) pixels:
另一方面，光栅图片造成了更大的挑战，因为它们以每像素为基础给图像编码。因此，像素数越多，光栅图片的文件体积也越大。举个例子，我们考虑一个以100x100(CSS)像素显示的照片资产之间的不同：

When we double the resolution the physical screen the total number of pixels increases by a factor of four: double the number of horizontal pixels, times double the number of vertical pixels. Hence, a “2x” screen not just doubles, but quadruples the number of required pixels!
当把物理屏幕分辨率翻倍，像素总数就增长为4倍：水平方向像素翻倍，乘以翻倍的垂直方向像素。因此，一个“2x”屏幕不仅是2倍，而是所需要像素数量的4倍！

So, what does this mean in practice? High resolution screens enable us to deliver beautiful images, which can be a great product feature. However, high resolution screens also require high-resolution images: prefer vector images whenever possible as they are resolution independent and always deliver sharp results, and if a raster image is required, deliver and optimize multiple variants of each image - keep reading for further details.
那么，这在实践中意味着什么呢？高分辨率的屏幕让我们能展示华丽的图片，会成为很棒的产品功能。然而，高分辨率屏幕也需要高分辨率的图片：只要有可能最好用矢量图因为它们是分辨率无关的而且总能清晰地显示，而如果需要光栅图片，交付并优化每个图片的各个方面 - 请继续阅读更多详情。

Optimizing vector images
优化矢量图片

TL;DR
简而言之

  ·SVG is an XML-based image format
  SVG是基于XML的图片格式
  ·SVG files should be minified to reduce their size
  SVG文件应该缩小以减少它们的体积
  ·SVG files should be compressed with GZIP
  SVG文件应该用GZIP压缩

All modern browsers support Scalable Vector Graphics (SVG), which is an XML-based image format for two-dimensional graphics: we can embed the SVG markup directly on the page, or as an external resource. In turn, an SVG file can be created by most vector-based drawing software, or by hand and directly in your favorite text editor.
所有现代浏览器都支持Scalable Vector Graphics (SVG)，这是一种为二维图形准备的基于XML的图像格式：我们能直接在页面里嵌入SVG标记，或者作为一个外部资源。反之，一个SVG文件可由大多数基于矢量的绘图软件生成，或者在你喜欢的文本编辑器里直接手写。

<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 17.1.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.2" baseProfile="tiny" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 612 792" xml:space="preserve">
<g id="XMLID_1_">
  <g>
    <circle fill="red" stroke="black" stroke-width="2" stroke-miterlimit="10" cx="50" cy="50" r="40"/>
  </g>
</g>
</svg>

The above example renders a simple circle shape with a black outline and red background and was exported from Adobe Illustrator. As you can tell, it contains a lot of metadata, such as layer information, comments, and XML namespaces that are often unnecessary to render the asset in the browser. As a result, it is always a good idea to minify your SVG files by running through a tool like svgo.
上面的示例渲染了一个简单的黑色外框红色背景的圆形，是由Adobe Illustrator导出的。象你能讲出来的那样，它包含了大量的元数据，例如层信息、注释以及XML命名空间，通常在浏览器里渲染资产时是不必要的。那么，通过svgo这样的工具来缩小你的SVG文件总是一个好主意(https://github.com/svg/svgo)。

Case in point, svgo reduces the size of the above SVG file generated by Illustrator by 58%, taking it from 470 to 199 bytes. Further, because SVG is an XML-based format, we can also apply GZIP compression to reduce its transfer size - make sure your server is configured to compress SVG assets!
实际证明，svgo将上面由Illustrator生成的SVG文件减少了58%，把它从470减少到199字节。而且，因为SVG是一种基于XML的格式，我们也可以应用GZIP压缩来减少它的传输大小 - 请确认你的服务器被配置来压缩SVG资产！

Optimizing raster images
优化光栅图片

TL;DR
简而言之

  ·A raster image is a grid of pixels
  光栅图片是一组像素栅格
  ·Each pixel encodes color and transparency information
  每个像素都要把颜色和透明度信息进行编码
  ·Image compressors use a variety of techniques to reduce the number of required bits per pixel to reduce file size of the image
  图片压缩器使用多种技术来减少每个像素需要的数据量从而达到减小图片文件大小的目标

A raster image is simply a 2-dimensional grid of individual “pixels” - e.g. a 100x100 pixel image is a sequence of 10,000 pixels. In turn, each pixel stores the “RGBA” values: (R) red channel, (G) green channel, (B) blue channel, and (A) alpha (transparency) channel.
光栅图片是一种简单的二维的由独立像素组成的栅格 - 例如，一个100x100像素的图片是10,000像素的序列。挨过来说，每个像素都保存了“RGBA”值：(R)红色通道(G)绿色通道(B)蓝色通道(A)透明通道。

Internally, the browser allocates 256 values (shades) for each channel, which translates to 8 bits per channel (28 = 256), and 4 bytes per pixel (4 channels x 8 bits = 32 bits = 4 bytes). As a result, if we know the dimensions of the grid we can easily calculate the filesize:
在内部处理中，浏览器为每个通道分配256个值(渐变的)，转换成每个通道8位(28=256)，每个像素4个字节(4通道x8位=32位=4字节)。如果我们知道栅格的定义很容易就能计算出文件大小：

  ·100 x 100px image is composed of 10,000 pixels
  ·10,000 pixels x 4 bytes = 40,000 bytes
  ·40,000 bytes / 1024 = 39 KB

Note
注意

  As an aside, regardless of the image format used to transfer the data from the server to the client, when the image is decoded by the browser, each pixel always occupies 4 bytes of memory. This can be an important constraint for large images and devices which do not have a lot of available memory - e.g. low-end mobile devices.
顺便说一句，不管从服务器端向客户端传输的图片格式是什么，当图片在浏览器被解码的时候，每个像素总是占据4字节的内存。对于没有大量可用内存的设备和大图片，这会是重要的限制因素 - 例如低端移动设备。

39KB for a 100x100 pixel image may not seem like a big deal, but the filesize quickly explodes for larger images and makes image assets both slow and expensive to download. Thankfully, what we’ve described so far is the “uncompressed” image format. What could we do to reduce the image file size?
39KB对于一个100x100像素的图片可能看上去不像个大问题，但是更大的图片文件体积迅速增长使得图片资产打开慢而且消耗更多下载流量。幸亏，到目前为止我们所叙述的只是“未压缩”的图片格式。要减少图片文件大小我们能做点什么呢？

One simple strategy is to reduce the “bit-depth” of the image from 8 bits per channel to a smaller color palette: 8 bits per channel gives us 256 values per channel and 16,777,216 (2563) colors in total. What if we reduced the palette to 256 colors? Then we would only need 8 bits in total for the RGB channels and immediately save two bytes per pixel – that’s 50% compression savings over our original 4 bytes per pixel format!
一个简单的策略就是减少图片的“位元深度”，从每通道8位改为较小的色板：每通道8位能有256个值总共16,777,216种颜色。如果我们减少色板到256色会是什么样？那我们只要给RGB通道总共8位就行了，每个像素立马就节省了2个字节 - 原本每像素4字节的格式就压缩了50%！

Note
备注

  Left to right (PNG): 32-bit (16M colors), 7-bit (128 colors), 5-bit (32 colors). Complex scenes with gradual color transitions (gradients, sky, etc.) require larger color palettes to avoid visual artifacts such as the pixelated sky in the 5-bit asset. On the other hand, if the image only uses a few colors, then a large palette is simply wasting precious bits!
  上面从左到右(PNG)分别是：32位(16M色)，7位(128色)，5位(32色)。复杂的有逐渐过渡颜色的场景(楼梯、天空等等)需要更大的色板来避免不自然的视觉效果，就像那个5位色的图片中像素化的天空那样。另一方面，如果图片只用到了很少的颜色，那么大色板就纯粹是浪费宝贵的位元！

Next, once we’ve optimized the data stored in individual pixels we could get more clever and look at nearby pixels as well: turns out, many images, and especially photos, have many nearby pixels with similar colors - e.g. the sky, repeating textures, and so on. Using this information to our advantage the compressor can apply “delta encoding” where instead of storing the individual values for each pixel, we can store the difference between nearby pixels: if the adjacent pixels are the same, then the delta is “zero” and we only need to store a single bit! But why stop there…
接下来，一旦我们已经优化了存储在独立像素中的数据，我们就能有更多好主意并把注意力放在邻近的像素上：结果是，许多图片，特别是照片，有很多邻近的像素有着近似的颜色 - 例如，天空、循环的材质等等。使用这个信息对我们的好处是压缩器可以应用“delta编码”而不是存储每个像素的独立值，我们可以存储相邻像素的差别：如果相邻的像素是一样的，那么dalta就是“0”而且我们只需存储一个位元！但是为什么不止步于此…

The human eye has different level of sensitivity to different colors: we can optimize our color encoding to account for this by reducing or increasing the palette for those colors. “Nearby” pixels form a two dimensional grid, which means that each pixel has multiple neighbors: we can use this fact to further improve delta encoding. Instead of looking at just the immediate neighbors for each pixel, we can look at larger blocks of nearby pixels and encode different blocks with different settings. And so on…
人类的眼睛对不同的颜色有不同级别的敏感度：我们能针对这个通过减少或增加那些颜色的色板优化颜色编码。“邻近”的像素构成了一个二维的格式，这意味着每个像素都有多个邻居：我们可以据此来进一步提升delta编码。别只盯着紧挨着的像素，我们可以放眼更大块的邻近像素并给不同的块用不同的设置。以此类推…

As you can tell, image optimization gets complicated quickly (or fun, depending on your perspective), and is an active area of academic and commercial research. Images occupy a lot of bytes and there is a lot of value in developing better image compression techniques! If you’re curious to learn more, head to the Wikipedia page, or check out the WebP compression techniques whitepaper for a hands-on example.
就像你看到的那样，图像优化很快就变得复杂了(或开句玩笑，根据你的立场)，而且也是理论和商业研究的活跃领域。图片占据了大量字节而开发更好的图像压缩技术很有价值。如果你有兴趣了解更多，来看Wikipedia页面(http://en.wikipedia.org/wiki/Image_compression)，或者参阅WebP压缩技术白皮书(https://developers.google.com/speed/webp/docs/compression)里的实用示例。

So, once again, this is all great, but also very academic: how does it help us optimize images on our pages? Well, we are definitely not in a position to invent new compression techniques, but it’s important to understand the shape of the problem: RGBA pixels, bit-depth, and various optimization techniques. All of these concepts are critical to understand and keep in mind before we dive into the discussions of various raster image formats.
那么，再说一次，这都很棒，但是很理论化：它如何帮我们优化页面上的图片呢？我们很明确不是要去发明新的压缩技术，但理解问题的成因是很重要的：RGBA像素、位元深度以及各种优化技术。在我们跳到各种光栅图像格式的讨论之前，理解并记住所有这些概念很重要。

Lossless vs lossy image compression
无损和有损图像压缩

TL;DR
简而言之

  ·Due to how our eyes work, images are great candidates for lossy compression
  由于眼睛的原理，图像非常适合做有损压缩
  ·Image optimization is a function of lossy and lossless compression
  图片优化是有损和无损压缩的功能
  ·Differences in image formats are due to the difference in how and which lossy and lossless algorithms are used to optimize the image
  不同图片格式之间的差别是由优化图片使用的有损和无损算法差别决定的。
  ·There is no single best format or "quality setting" for all images: each combination of particular compressor and image contents produce a unique output
  没有一种最佳格式或“高质量设置”能用于所有图像：每种流行的压缩器和图像内容的结合都产生了一种单独的输出。


For certain types of data, such as source code for a page, or an executable file, it is critical that a compressor does not alter or lose any of the original information: a single missing or wrong bit of data could completely change the meaning of the contents of the file, or worse, break it entirely. For some other types of data, such as images, audio, and video, it may be perfectly acceptable to deliver an “approximate” representation of the original data.
对于某种类型的数据，比如页面的源代码，或者一个可执行文件，压缩器不替换或丢失任何原始信息是非常关键的：一个位元的丢失或错误就会整个改变文件的内容，也可能更糟，彻底地破坏掉它。对于其他类型的数据，比如图像，音频和视频，它会很容易接受和原始数据差不多就行。

In fact, due to how they eye works, we can often get away with discarding some information about each pixel in order to reduce the filesize of an image - e.g. our eyes have different sensitivity to different colors, which means that we can use fewer bits to encode some colors. As a result, a typical image optimization pipeline consists of two high level steps:
实际上，针对眼睛的工作原理，我们通常用放弃一些像素的信息来减少图片的文件大小 - 例如，人眼对不同颜色有不同的敏感度，这意味着我们可以用很少的位元对某些颜色进行编码。因此，一个典型的图片优化途径由两个高级步骤组成：

  ·Image is processed with a “lossy” filter that eliminates some pixel data
  图片被“有损”处理，丢掉某些像素的数据
  ·Image is processed with a “lossless” filter that compresses the pixel data
  图片被“无损”处理，压缩像素数据

The first step is optional, and the exact algorithm will depend on the particular image format, but it is important to understand that any image can undergo a lossy compression step to reduce its size. In fact, the difference between various image formats, such as GIF, PNG, JPEG, and others, is in the combination of the specific algorithms they use (or omit) when applying the lossy and lossless steps.
第一步是可选的，具体的算法要看特定图像格式，但是理解了任何图像都能经过有损压缩步骤来减少它的大小是很重要的。实际上，不同图像格式之间的差别，比如GIF、PNG、JPEG以及其他的，在于给它们应用有损和无损步骤时所用的特定算法的结合(或省略)。

So, what is the “optimal” configuration of lossy and lossless optimization? The answer depends on the image contents and your own criteria such as the tradeoff between filesize and artifacts introduced by lossy compression: in some cases you may want to skip lossy optimization to communicate intricate detail in its full fidelity, and in others you may be able to apply aggressive lossy optimization to reduce the filesize of the image asset. This is where your own judgment and context need to come into play - there is no one universal setting.
那么，什么才是最理想的有损和无损优化配置呢？答案要看图像内容和你自己的标准，比如在文件大小和有损压缩造成的失真之间权衡：在某些情况下你或许想要跳过有损优化来表达复杂的细节以保持其完整精确，别的时候你可或许能应用深度的有损优化来减少图片资产的文件大小。这是由你自己决定以及上下文需要来发挥作用 - 没有一个通用的设定。

As a hands-on example, when using a lossy format such as JPEG, the compressor will typically expose a customizable “quality” setting (e.g. the quality slider provided by the “Save for Web” functionality in Adobe Photoshop), which is typically a number between 1 and 100 that controls the inner workings of the specific collection of lossy and lossless algorithms. For best results, experiment with various quality settings for your images, and don’t be afraid to dial down the quality - the visual results are often very good and the filesize savings can be quite large.
实际操作时，当使用有损格式比如JPEG，压缩器一般会显示一个自定义“质量”设置(例如，在Adobe Photoshop中“保存成网页”功能里提供的质量滑杆)，一般用1到100之间的数值来控制有损和无损算法的内部运行。为了得到最理想的结果，对你的图片进行不同的质量设置体验看体验如何，不要害怕降低质量 - 可视效果通常会很好而且文件大小也能节省很多。

Note
备注

  Note that quality levels for different image formats are not directly comparable due to differences in algorithms used to encode the image: quality 90 JPEG will produce a very different result than a quality 90 WebP. In fact, even quality levels for the same image format may produce visibly different output based on implementation of the compressor!
  注意因为用于编码图像的算法上的不同，质量级别对于不同的图像格式不都是直接相同的：JPEG质量90与WebP质量90产生的结果非常不同。事实上，对于同样的图片格式质量级别也会产生明显不同的输出，主要看压缩器的执行。

Selecting the right image format
选择正确的图片格式

TL;DR
简而言之

  ·Start by selecting the right universal format: GIF, PNG, JPEG
  从选择正确的常用格式开始：GIF、PNG、JPEG
  ·Experiment and select the best settings for each format: quality, palette size, etc.
  体验并选定每种格式最佳设置：质量、色板大小等等
  ·Consider adding WebP and JPEG XR assets for modern clients
  考虑给现代浏览器添加WebP和JPEG XR资产

In addition to different lossy and lossless compression algorithms, different image formats support different features such as animation and transparency (alpha) channels. As a result, the choice of the “right format” for a particular image is a combination of desired visual results and functional requirements.
除了不同的有损和无损压缩算法，不同的图像格式还支持不同的功能比如动画和透明(alpha)通道。因此，对特定图片“正确格式”的选择是对渴望的显示效果和功能需求的综合考量。

There are three universally supported image formats: GIF, PNG, and JPEG. In addition to these formats, some browsers also support newer formats such as WebP and JPEG XR, which offer better overall compression and more features. So, which format should you use?
有三种被普遍支持的图片格式：GIF、PNG和JPEG。除了这些格式，一些浏览器还支持更新的格式比如WebP和JPEG XR，它们能提供更好的压缩和更多功能。那么，你应该用哪种格式呢？

  01 Do you need animation? If so, GIF is the only universal choice.
  需要动画吗？GIF是惟一的通用选择。

    ·GIF limits the color palette to at most 256 colors, which makes it a poor choice for most images. Further, PNG-8 delivers better compression for images with a small palette. As a result, GIF is the right answer only when animation is required.
    GIF限制色板为最多256色，这使得它对于大多数图像来说是个不好的选择。而且，PNG-8为色板小的图片提供更好的压缩。那么，GIF只在需要动画的时候才是正确选择。

  02 Do you need to preserve fine detail with highest resolution? Use PNG.
  你需要在高分辨率下保持良好细节吗？使用PNG。
    ·PNG does not apply any lossy compression algorithms beyond the choice of the size of the color palette. As a result, it will produce the highest quality image, but at a cost of significantly higher filesize than other formats. Use judiciously.
    PNG在对色板大小的选择上不应用任何有损压缩算法。结果就是，它将产生最高的图像质量，但是相比其他格式来说文件大小也高得多。要谨慎使用。
    ·If the image asset contains imagery composed of geometric shapes, consider converting it to a vector (SVG) format!
    如果图片资产包含几何图形构成的形象，考虑把它转换成矢量(SVG)格式！
    ·If the image asset contains text, stop and reconsider. Text in images is not selectable, searchable, or “zoomable”. If you need to convey a custom look (for branding or other reasons), use a web font instead.
    如果图片资产包含文本，停下并重新考虑。图片里的文本无法被复制、不能搜索也不能缩放。如果你需要表达一个定制的视觉形象(为了品牌或其他原因)，请使用web字体作为替代。

  03 Are you optimizing a photo, screenshot, or a similar image asset? Use JPEG.
  你在优化照片、截屏或类似的图片资产吗？使用JPEG。
    ·JPEG uses a combination of lossy and lossless optimization to reduce filesize of the image asset. Try several JPEG quality levels to find the best quality vs. filesize tradeoff for your asset.
    JPEG综合使用了有损和无损优化来减少图片文件大小。尝试几种JPEG质量等级来找出最佳的质量和大小的权衡。

Finally, once you’ve determined the optimal image format and its settings for each of your assets, consider adding an additional variant encoded in WebP and JPEG XR. Both of of these formats are new, and unfortunately are not (yet) universally supported by all browsers, but they can nonetheless provide significant savings for newer clients - e.g. on average, WebP delivers a 30% filesize decrease over a comparable JPEG image.
最终，一旦你已经确定了每项资产的最佳图片格式和设置，考虑增加其他的不同编码WebP和JPEG XR。这些格式都是新的，而不幸的是还不能被所有浏览器普遍支持，但尽管如此它们能为新的客户端提供相当大的节省 - 例如，平均来看，WebP能比同等的JPEG图片减少30%(https://developers.google.com/speed/webp/docs/webp_study)的文件大小。

Since neither WebP and JPEG XR are universally supported, you will need to add additional logic to your application or servers to serve the appropriate resource:
因为WebP和JPEG XR不被普遍支持，你将需要在你的应用或服务器中添加额外的逻辑来提供适当的资源：

  ·Some CDNs provide image optimization as a service, including JPEG XR and WebP delivery.
  有些CDN支持将图片优化作为一项服务，包括JPEG XR和WebP交付。
  ·Some open-source tools (e.g. PageSpeed for Apache or Nginx) automate the optimization, conversion, and serving of appropriate assets.
  有些开源工具(例如，PageSpeed For Apache或Nginx)能把优化、转换和服务自动化进行。
  ·You can add additional application logic to detect the client, check which formats they support, and serve the best available image format.
  你可以添加附加应用逻辑来探测客户端，查看它们支持何种格式，并提供最佳可用格式。

Finally, note that if you are using a Webview to render content in your native application, then you have full control of the client and can use WebP exclusively! Facebook, Google+ and many others use WebP to deliver all of their images within their applications - the savings are definitely worth it. To learn more about WebP, checkout the WebP: Deploying Faster, Smaller, and More Beautiful Images presentation from Google I/O 2013.
最终，注意如果你在使用Webview在你的原生应用中渲染内容，那么你就拥有完整的客户端控制并能专门使用WebP！Facebook，Google+以及很多其他公司都在他们的应用中用WebP传送所有图片 - 节省量是非常值得的。更进一步学习WebP，请参阅Google I/O 2013发布的WebP: Deploying Faster, Smaller, and More Beautiful Images(https://www.youtube.com/watch?v=pS8udLMOOaE)。

Tools and parameter tuning
工具和参数调整

There is no one perfect image format, tool, or a set of optimization parameters that apply to all images. For best results you will have to pick the format and its settings depending on the contents of the image, and its visual and other technical requirements.
没有完美的图片格式、工具或一套优化参数可以应用于所有图片。为了最好的效果你得根据图片内容、挑选格式与其参数，以及视觉还有其他技术需求。

gifsicle	create and optimize GIF images
gifsicle(http://www.lcdf.org/gifsicle/) 生成并优化GIF图片

jpegtran	optimize JPEG images
jpegtran(http://jpegclub.org/jpegtran/) 优化JPEG图片

optipng	lossless PNG optimization
optipng(http://optipng.sourceforge.net/) 无损PNG优化

pngquant	lossy PNG optimization
pngquant(http://pngquant.org/) 有损PNG优化

Don’t be afraid to experiment with parameters of each compressor. Dial down the quality, see how it looks, then rinse, lather and repeat. Once you’ve found a good set of settings, you can apply them to other similar images on your site, but don’t assume that all images must be compressed with the same settings.
不要害怕去体验每种压缩器的参数。下调质量，看它看上去如何，然后清除，重复尝试。一旦你找到好的设置，你可以应用到网站上其他类似的图片上，但是不要假设所有的图片都必须用同样的设置压缩。

Delivering scaled image assets
交付缩略图资产

TL;DR
简而言之

  ·Delivering scaled assets is one of the simplest and most effective optimizations
  交付缩略资产是最简单最有效的优化之一
  ·Pay close attention to large assets as they result in high overhead
  对大资产要多加注意因为它们产生大报头
  ·Reduce the number of unnecessary pixels by scaling your images to their display size
  通过缩小图片到它们的显示大小来减少不必要的像素数量

Image optimization boils down to two criteria: optimizing the number of bytes used to encode each image pixel, and optimizing the total number of pixels: the filesize of the image is simply the total number of pixels times the number of bytes used to encode each pixel. Nothing more, nothing less.
图片优化归结为两个标准：优化用于给每个图片像素编码的字节数，和优化总像素数：图片文件大小就是简单地把总像素数乘以为每个像素编码的字节数。不多也不少。

As a result, one of the simplest and most effective image optimization techniques is to ensure that we are not shipping any more pixels than needed to display the asset at its intended size in the browser. Sounds simple, right? Unfortunately, most pages fail this test for many of their image assets: typically, they ship larger assets and rely on the browser to rescale them - which also consumes extra CPU resources - and display them at a lower resolution.
结果就是，最简单有效地图片优化技术之一就是确保我们不用运送比在浏览器中显示的大小更多的像素。听起来挺简单的吧？不幸的是，大部分页面上的很多图片都没能通过这项测试：常见于它们传送了更大的资产并依赖浏览器去缩放它们 - 而这也消耗额外的CPU资源 - 并用低一些的分辨率来显示它们。

Note
注意

Hovering over the image element in Chrome DevTools reveals both the "natural" and "display" sizes of the image asset. In above example the 300x260 pixel image is downloaded but is then downscaled (245x212) on the client when it is displayed.
在Chrome开发人员工具中悬停在图片元素上，会在图片上同时显示“原始”和“显示”大小。在上面示例中下载的是300x260像素图片但是显示的时候被缩小了(245x212)。

The overhead of shipping unnecessary pixels, only to have the browser rescale the image on our behalf, is a big missed opportunity to reduce and optimize the total number of bytes required to render the page. Further, note that resizing is not simply a function of the number of pixels by which the image is reduced by, but also of its natural size.
只在浏览器出于需要而缩放图片的时候，会运送不必要的像素，这是会错失很大的机会来减少并优化用来渲染页面需要的总像素数。因此，注意重设大小不简单是个让能图片通过它来减少像素数的功能，同时也要减少它的原始尺寸。

Natural size	Display size	Unnecessary pixels
110 x 110	100 x 100	110 x 110 - 100 x 100 = 2100
410 x 410	400 x 400	410 x 410 - 400 x 400 = 8100
810 x 810	800 x 800	810 x 810 - 800 x 800 = 16100

Note that in all three cases above the display size is “only 10 pixels smaller” than the natural size of the image. However, the number of extra pixels that we would have to encode and ship is significantly higher the larger the natural size! As a result, while you may not be able to guarantee that every single asset is delivered at the exact display size, you should ensure that the number of unnecessary pixels is minimal, and that your large assets in particular are delivered as close as possible to their display size.
注意到在上述三种情况中图片显示大小都比原始尺寸“只小了10像素”。然而，原始尺寸越大要额外编码和运输的像素数就越显著增加。因此，在你可能无法保证所有单个资产都能按确切的显示尺寸传送的时候，你要确保非必要的像素是最少的，而且体积大的资产尤其要尽可能地按他们的显示尺寸交付。

Image optimization checklist
图像优化清单

Image optimization is both an art and a science: an art because there is no one definitive answer for how to best compress an individual image, and a science because there are well-developed techniques and algorithms that can help significantly reduce the size of an image.
图像优化既是艺术也是科学：说艺术是因为对于如何最好地压缩一个单独的图片没有明确的答案，说科学是因为有发展良好的技术和算法能帮助显著减少图片大小。

Some tips and techniques to keep in mind as you work on optimizing your images:
在优化图片的工作中要牢记的一些窍门和技术：

  ·Prefer vector formats: vector images are resolution and scale independent, which makes them a perfect fit for the multi-device and high-resolution world.
  首选矢量格式：矢量图是与分辨率和缩放无关的，这使得它们非常适合跨设备和高分辨率场合。
  ·Minify and compress SVG assets: XML markup produced by most drawing applications often contains unnecessary metadata which can be removed; ensure that your servers are configured to apply GZIP compression for SVG assets.
  减小并压缩SVG资产：大部分绘图应用生成的XML标记通常包含着可删除的元数据；确保服务器被配置过可为SVG资产应用GZIP压缩。
  ·Pick best raster image format: determine your functional requirements and select the one that suits each particular asset.
  挑选最好的光栅图像格式：确定你的功能需求并为特定资产选择合适的格式。
  ·Experiment with optimal quality settings for raster formats: don’t be afraid to dial down the “quality” settings, the results are often very good and byte savings are significant.
  为光栅格式体验理想的质量设定：不要害怕调低“质量”设置，结果通常都很好而且能节省可观的字节。
  ·Remove unnecessary image metadata: many raster images contain unnecessary metadata about the asset: geo information, camera information, and so on. Use appropriate tools to strip this data.
  去除不必要的图像元数据：一些光栅图像包含不必要的关于资产的元数据：地理位置信息、相机信息等等。使用合适的工具来剔除这些数据。
  ·Serve scaled images: resize images on the server and ensure that the “display” size is as close as possible to the “natural” size size of the image. Pay close to attention to large images in particular, as they account for largest overhead when resized!
  提供缩放过的图片：在服务器端缩放图片并确保真实大小尽可能和显示大小一致。尤其要注意大图片，当缩放的时候它们的花费最大！
  ·Automate, automate, automate: invest into automated tools and infrastructure that will ensure that all of your image assets are always optimized.
  自动化、自动化、自动化：投资自动化工具和基础设施将确保你所有的图片资产都能被优化。


============================
HTTP caching
HTTP缓存
============================

Fetching something over the network is both slow and expensive: large responses require many roundtrips between the client and server, which delays when they are available and can be processed by the browser, and also incurs data costs for the visitor. As a result, the ability to cache and reuse previously fetched resources is a critical aspect of optimizing for performance.
通过网络获取点东西又慢又贵：大的响应需要在客户端和服务器多次往返，在等待网络可用并能被浏览器处理时会发生延迟，而且也会对用户产生大量的数据流量费用。因此，缓存和重用之前已取得资源的能力是优化性能的关键点。

In this guide
本节主要内容

  ·Validating cached responses with ETags
  使用ETag校验缓存的响应
  ·Cache-Control
  缓存控制
  ·Defining optimal Cache-Control policy
  定义最佳缓存控制政策
  ·Invalidating and updating cached responses
  将缓存的响应作废并更新
  ·Caching checklist
  缓存清单

Great news, every browser ships with an implementation of an HTTP cache! All we have to do is ensure that each server response provides correct HTTP header directives to instruct the browser on when and for how long the response can be cached by the browser.
好消息，每次浏览器数据传输都带着HTTP缓存！我们要做的就是确保每个服务器响应都能提供正确的HTTP头指令，来通知浏览器何时缓存响应以及缓存多久。

If you are using a Webview to fetch and display web content in your application, you may need to provide additional configuration flags to ensure that the HTTP cache is enabled, its size is set to a reasonable number to match your use case, and that the cache is persisted. Check the platform documentation and confirm your settings!
如果在你的应用里使用Webview来获取并显示web内容，你或许要提供其他的配置标记来确保HTTP缓存是启用的，它的大小被设置成合理的数字以匹配你的使用情况，而且缓存是永久的。查看平台文档确认你的设置！

When the server returns a response it also emits a collection of HTTP headers, describing its content-type, length, caching directives, validation token, and more. For example, in above exchange the server returns a 1024 byte response, instructs the client to cache it for up to 120 seconds, and provides a validation token (“x234dff”) that can be used after the response has expired to check if the resource has been modified.
当服务器返回一个响应它同时也发出了HTTP头集合，描述了它的内容类型、长度、缓存指令、检验码等等。例如，上述服务器返回了1024字节的响应，指示客户端缓存直到120秒，而且提供了一个校验码(“x234dff”)可用于当响应失效后检查资源是否被修改。

Validating cached responses with ETags
用ETag检验缓存的响应

TL;DR
简而言之

  ·Validation token is communicated by the server via the ETag HTTP header
  检验码由服务器通过ETag HTTP头来传达
  ·Validation token enables efficient resource update checks: no data transfer if the resource has not changed.
  检验码使得资源可以高效检查更新：如果资源没有变化就没有数据传输

Let’s assume 120 seconds have passed since our initial fetch and the browser has initiated a new request for the same resource. First, the browser checks the local cache and finds the previous response, unfortunately it cannot use it as the response has now “expired”. At this point it could simply dispatch a new request and fetch the new full response, but that’s inefficient because if the resource has not changed then there is no reason to download the exact same bytes that are already in cache!
让我们来假设一下自初次获取资源已经过去了120秒而且浏览器对同一个资源发起了新的请求。首先，浏览器会检查本地缓存并且查找上次的响应，不幸的是已经不能用了因为响应现在“过期了”。在这时候它可以简单地发起一个新的请求而且获取新的完整的响应，但是这效率太差因为这个资源并没有被修改没有理由再去把已经在缓存里的相同的字节再下载一遍！

That’s the problem that validation tokens, as specified in the ETag header, are designed to solve: the server generates and returns an arbitrary token which is typically a hash or some other fingerprint of the contents of the file. The client does not need to know how the fingerprint is generated, it only needs to send it to the server on the next request: if the fingerprint is still the same then the resource has not changed and we can skip the download.
这就是在ETag头里指定的检验码被设计来解决的问题：服务器生成并返回一个专用的标记常见是hash串或一些其他的文件内容的指纹。客户端无须知道指纹如何生成，只需在下一次请求中把它发送到服务器：如果指纹还是同一个那么资源没有被修改我们就不用下载了。

In above example the client automatically provides the ETag token within the “If-None-Match” HTTP request header, the server checks the token against the current resource, and if it has not changed returns a “304 Not Modified” response which tells the browser that the response it has in cache has not changed and can be renewed for another 120 seconds. Note that we do not have to download the response once more - this saves time and bandwidth.
在上述示例中，客户端自动在HTTP请求头“If-None-Match”中提供了ETag标记，服务器在当前资源中检查该标记，如果没有被改变就返回“304 Not Modified”响应告诉浏览器它所缓存的这个响应没有变化可以再用120秒。注意我们不用再下载一次这个响应 - 这节省了时间和带宽。

As a web developer, how do you take advantage of efficient revalidation? The browser does all the work on our behalf: it will automatically detect if a validation token has been previously specified, it will append it to an outgoing request, and it will update the cache timestamps as necessary based on received response from the server. The only thing that’s left for us to do is to ensure that the server is, in fact, providing the necessary ETag tokens: check your server documentation for necessary configuration flags.
作为一名Web开发人员，你如何利用高效重检验呢？浏览器为我们做好了一切：它将自动检测之前是否指定过一个检验码，把它应用到发出的请求中，将且根据从服务器接收到的响应必要时更新缓存时间戳。我们要做的只是确保服务器确定提供了必要的ETag标记：检查你的服务器文档中那些必要的配置标志。

Remember
切记

Tip: HTML5 Boilerplate project contains sample configuration files for all the most popular servers with detailed comments for each configuration flag and setting: find your favorite server in the list, look for appropriate settings, and copy / confirm that your server is configured with recommended settings.
提示：HTML5 Boilerplate项目包含了绝大多数流行服务器的示例配置文件并为每个配置标记和设置配有详细的注释：在列表中找到你喜欢的服务器，看看那些适合的设置，复制/确认你的服务器是以推荐设置进行了配置。

Cache-Control
缓存控制

TL;DR
简而言之

  ·Each resource can define its caching policy via Cache-Control HTTP header
  每个资源都可通过Cache-Control HTTP头来定义它的缓存策略
  ·Cache-Control directives control who can cache the response, under which conditions, and for how long
  Cache-Control指令控制谁能缓存响应，在何种条件下，以及多长时间
  ·The best request is a request that does not need to communicate with the server: a local copy of the response allows us to eliminate all network latency and avoid data charges for the data transfer. To achieve this, the HTTP specification allows the server to return a number of different Cache-Control directives that control how, and for how long, the individual response can be cached by the browser and other intermediate caches.
  最好的请求就是不需要与服务器通信的请求：一份本地的响应拷贝让我们消除了所有的网络延迟而且避免了数据传输的流量费用。为了实现这一点，HTTP说明书允许服务器返回许多不同的Cache-Control指令来控制单独的响应可以被浏览器和其他的中间缓存如何缓存以及缓存多长时间。

Remember
切记

Cache-Control header was defined as part of the HTTP/1.1 specification and supersedes previous headers (e.g. Expires) used to define response caching policies. All modern browsers support Cache-Control, hence that is all we will need.
Cache-Control头被下定义为HTTP/1.1说明书的一部分，并且取代了之前用于定义响应缓存政策的返回头(例如，Expires)。所有现代浏览器都支持Cahce-Control，因此这就是我们所要的。

“no-cache” and “no-store”
“no-cache”和“no-store”

“no-cache” indicates that the returned response cannot be used to satisfy a subsequent request to the same URL without first checking with the server if the response has changed. As a result, if a proper validation token (ETag) is present, no-cache will incur a roundtrip to validate the cached response, but can eliminate the download if the resource has not changed.
“no-cache”指示返回的响应不能用于在响应被改变时不与服务器做首次检查的后续相同URL请求。那么，如果提供了一个适当的校验码，no-cache将引发一个校验被缓存响应的往返，但是资源没有改变的时候可以不下载它。

By contrast, “no-store” is much simpler, as it simply disallows the browser and all intermediate caches to store any version of the returned response - e.g. one containing private personal or banking data. Everytime the user requests this asset, a request is sent to the server and a full response is downloaded each and every time.
相比之下，“no-store”就简单多了，它只是简单地禁止浏览器以及其他所有中间缓存去保存任何版本的返回响应 - 例如，包含私人或银行信息的数据。每次用户请求这种资产，都要向服务器发送一个请求而且每次都下载完整的响应。

“public” vs. “private”
“public” 与 “private”

If the response is marked as “public” then it can be cached, even if it has HTTP authentication associated with it, and even when the response status code isn’t normally cacheable. Most of the time, “public” isn’t necessary, because explicit caching information (like “max-age”) indicates that the response is cacheable anyway.
如果响应被标为“Public”那么它就能被缓存，即使它绑定了HTTP认证，甚至响应状态码不是通常的可缓存。大部分时候，“public”不是必要的，因为明确的缓存信息(像“max-age”)指出了响应至少是可缓存的。

By contrast, “private” responses can be cached by the browser but are typically intended for a single user and hence are not allowed to be cached by any intermediate cache - e.g. an HTML page with private user information can be cached by that user’s browser, but not by a CDN.
相比之下，“private”响应能被浏览器缓存但典型是为单个用户准备的因而不允许被任何中间层缓存去保存它 - 例如，带有私人用户信息的HTML页面能被用户浏览器缓存，但是不能被CDN缓存。

“max-age”
“max-age”

This directive specifies the maximum time in seconds that the fetched response is allowed to be reused for from the time of the request - e.g. “max-age=60” indicates that the response can be cached and reused for the next 60 seconds.
这个命令以秒为单位指定了获得的响应从发起请求的时间开始可以重复使用的最长时间 - 例如，“max-age=60”指出响应可以被缓存而且在接下来的60秒内重复使用。

Defining optimal Cache-Control policy
定义最佳缓存控制政策

是可重用响应吗？
  1.1 否 no-store
  1.2 是 每次都要校验吗？
    2.1 是 no-cache
    2.2 否 可以被中间层缓存保存吗？
      3.1 是 public
      3.2 否 private
  4 有最大剩余缓存时间吗？ 设置 max-age=
  5 加上ETag头

Follow the decision tree above to determine the optimal caching policy for a particular resource, or a set of resources used by your application. Ideally, you should aim to cache as many responses as possible on the client for the longest possible period, and provide validation tokens for each response to enable efficient revalidation.
沿着上述判断树来为特定资源确定最佳缓存政策，或者一系列你的应用使用的资源。理想状态下，你应该旨在缓存尽可能多的响应并尽可能时间长一些，并为每个响应提供校验码使得再校验更高效。

According to HTTP Archive, amongst the top 300,000 sites (by Alexa rank), nearly half of all the downloaded responses can be cached by the browser, which is a huge savings for repeat pageviews and visits! Of course, that doesn’t mean that your particular application will have 50% of resources that can be cached: some sites can cache 90%+ of their resources, while others may have a lot of private or time-sensitive data that can’t be cached at all.
根据HTTP Archive的统计，在前300,000名网站中(Alexa排名)，将近半数的所有下载的响应都能被浏览器缓存，这对那些反复访问和页面浏览来说是一笔巨大的节省！当然，这并不意味着你特定的应用将有50%的资源能被缓存：有些网站能把它们的资源缓存90%以上，而另一些可能有大量的私人的或时效性的数据根本不能被缓存。

Audit your pages to identify which resources can be cached and ensure that they are returning appropriate Cache-Control and ETag headers.
审计你的页面标出那些可以被缓存的资源并确保它们能返回适当的Cache-Control和ETag头。

Invalidating and updating cached responses
失效和更新已缓存的响应

TL;DR
简而言之

  ·Locally cached responses are used until the resource 'expires'
  本地被缓存的响应会被用到直至资源“过期”
  ·Embedding a file content fingerprint in the URL enables us to force the client to update to a new version of the response
  在URL中嵌入文件内容指纹能强制客户端更新一个新版的响应
  ·Each application needs to define its own cache hierarchy for optimal performance
  每个应用都需要为最佳性能而定义它自己的缓存层级

All HTTP requests made by the browser are first routed to the browser cache to check if there is a valid cached response that can be used to fulfill the request. If there is a match, the response is read from the cache and we eliminate both the network latency and the data costs incurred by the transfer. However, what if we want to update or invalidate a cached response?
所有浏览器产生的HTTP请求首先被路由到浏览器缓存以检查是否有可用的缓存响应可用于满足请求。如果能匹配，响应就被从缓存中读出而且没有了网络延迟和由传输引发的数据花费。然而，如果我们要把被缓存的响应更新或失效会怎么样？

For example, let’s say we’ve told our visitors to cache a CSS stylesheet for up to 24 hours (max-age=86400), but our designer has just committed an update that we would like to make available to all users. How do we notify all the visitors with what is now a “stale” cached copy of our CSS to update their caches? It’s a trick question - we can’t, at least not without changing the URL of the resource.
举例来说，我们告诉访问者将CSS样式缓存到24小时(max-age=86400)，但是我们的设计师刚刚提交了想要对所有用户生效的更新。我们怎么通知所有的访问者现在有一个“过期”的CSS缓存拷贝要更新它们的缓存？这问题真难回答 - 我们不能，至少不用改变资源的URL。

Once the response is cached by the browser, the cached version will be used until it is no longer fresh, as determined by max-age or expires, or until it is evicted from cache for some other reason - e.g. the user clearing their browser cache. As a result, different users might end up using different versions of the file when the page is constructed; users who just fetched the resource will use the new version, while users who cached an earlier (but still valid) copy will use an older version of its response.
一旦响应被浏览器缓存住，被缓存的版本会被使用直到由max-age或expires决定它不再有效为止，或直到由于某些其他原因被从缓存中清理掉 - 例如，用户清除浏览器缓存。那么，最终在页面被构建的时候不同的用户可能使用着不同版本的文件；刚获得资源的用户将使用新版本，而之前缓存了早期拷贝的用户(仍然有效)将使用旧版本的响应。

So, how do we get the best of both worlds: client-side caching and quick updates? Simple, we can change the URL of the resource and force the user to download the new response whenever its content changes. Typically, this is done by embedding a fingerprint of the file, or a version number, in its filename - e.g. style.x234dff.css.
那么，我们如何达成共赢的局面：客户端缓存和快速更新？简单，我们可以改变资源的URL并在它的内容改变的时候强制用户下载新的响应。典型的作法是，通过在它的文件名中嵌入文件指纹或版本号 - 例如，style.x234dff.css。

The ability to define per-resource caching policies allows us to define “cache hierarchies” that allow us to control not only how long each is cached for, but also how quickly new versions are seen by visitor. For example, let’s analyze the above example:
为每个资源定义缓存政策的能力使得我们能定义“缓存层级”，从而不仅能控制每个缓存多久，而且新版本多快能被访问者看到。举例来说，让我们分析上面的示例：

The HTML is marked with “no-cache”, which means that the browser will always revalidate the document on each request and fetch the latest version if the contents change. Also, within the HTML markup we embed fingerprints in the URLs for CSS and JavaScript assets: if the contents of those files change, than the HTML of the page will change as well and new copy of the HTML response will be downloaded.
HTML被标记为“no-cache”，这意味着浏览器将总是在每次请求的时候重新校验文档并在内容改变的时候获取最近的版本。同样的，在HTML标记内的CSS和JavaScriptURL中嵌入指纹：如果这些文件的内容发生变化，页面的HTML也将改变，新的HTML响应拷贝将被下载。

The CSS is allowed to be cached by browsers and intermediate caches (e.g. a CDN), and is set to expire in 1 year. Note that we can use the “far future expires” of 1 year safely because we embed the file fingerprint its filename: if the CSS is updated, the URL will change as well.
CSS是允许被缓存在浏览器或中间缓存(例如，CDN)上的，而且被设成1年过期。注意我们能安全地使用一年的“长久未来过期时间”因为我们在文件名中嵌入了文件指纹：如果CSS被更新了，URL也会改变。

The JavaScript is also set to expire in 1 year, but is marked as private, perhaps because it contains some private user data that the CDN shouldn’t cache.
JavaScript也被设置成1年过期，但是被标记成私人的，也许因为它包含了一些CDN不能缓存的私人用户数据。

The image is cached without a version or unique fingerprint and is set to expire in 1 day.
图片被缓存成不带版本号和独立指纹而且设置成1天过期。

The combination of ETag, Cache-Control, and unique URLs allows us to deliver the best of all worlds: long-lived expiry times, control over where the response can be cached, and on-demand updates.
ETag、Cache-Control以及独立URL的结合使得我们能实现各方面都最好：长期存活的逾期时间、对于能被缓存的响应的控制以及按需更新。
Caching checklist
缓存清单

There is no one best cache policy. Depending on your traffic patterns, type of data served, and application-specific requirements for data freshness, you will have to define and configure the appropriate per-resource settings, as well as the overall “caching hierarchy”.
没有最好的缓存政策。根据你的传输模式，提供的数据类型，以及应用对数据刷新率的特定需求，你得去为每个资源定义和配置合适的设置，还有总体的“缓存层级”。

Some tips and techniques to keep in mind as you work on caching strategy:
在你着手制定缓存策略的时候要牢记一些窍门和技术：

  01 Use consistent URLs: if you serve the same content on different URLs, then that content will be fetched and stored multiple times. Tip: note that URLs are case sensitive!
  使用一致的URL：如果你用不同的URL提供相同的内容，那么内容会被多次获取并保存。提示：注意URL是对场景敏感的。
  02 Ensure the server provides a validation token (ETag): validation tokens eliminate the need to transfer the same bytes when a resource has not changed on the server.
  确保服务器提供校验码：当资源在服务器上没有变化的时候校验码可以消除对相同字节的传输需求。
  03 Identify which resources can be cached by intermediaries: those with responses that are identical for all users are great candidates to be cached by a CDN and other intermediaries.
  标出能被中间层缓存的资源：那些对所有用户有着同一的响应非常适合用CDN或其他中间层来缓存。
  04 Determine the optimal cache lifetime for each resource: different resources may have different freshness requirements. Audit and determine the appropriate max-age for each one.
  确定每个资源最佳缓存生命期：不同的资源可能有不同的刷新需求。审计并确定每个适合的max-age。
  05 Determine the best cache hierarchy for your site: the combination of resource URLs with content fingerprints, and short or no-cache lifetimes for HTML documents allows you to control how quickly updates are picked up by the client.
  为你的网站确定最佳缓存层级：给资源URL绑定内容指纹，并且缩短或no-cacheHTML文档的生命期，使得你能控制由客户端得到多快速的更新。
  06 Minimize churn: some resources are updated more frequently than others. If there is a particular part of resource (e.g. JavaScript function, or set of CSS styles) that are often updated, consider delivering that code as a separate file. Doing so allows the remainder of the content (e.g. library code that does not change very often), to be fetched from cache and minimizes the amount of downloaded content whenever an update is fetched.
  最小化翻腾：一些资源比其他的更新频繁得多。如果资源的某一部分(例如，JavaScript函数，或者CSS样式的设置)经常被更新，考虑把这些代码作为一个单独的文件传送。这样做让其余的内容(例如，不经常变化的库代码)，从缓存中获取并且在获取更新的时候最小化下载总量。


